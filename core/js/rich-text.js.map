{"version":3,"file":"rich-text.js","mappings":";;;;;;;;;;AAAA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,mBAAmB;AACnB,wBAAwB,mBAAO,CAAC,wJAAqB;AACrD;AACA;AACA;;AAEA,cAAc,iCAAiC;AAC/C,cAAc,kCAAkC;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,iCAAiC,kBAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;;;;;;;;;;AC5Fa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf,oBAAoB,mBAAO,CAAC,sJAAsB;AAClD,mBAAmB,mBAAO,CAAC,kJAAoB;AAC/C,aAAa,mBAAO,CAAC,oIAAa;AAClC,sBAAsB,mBAAO,CAAC,0JAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AChDa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf,gBAAgB,mBAAO,CAAC,gDAAqB;AAC7C,cAAc,mBAAO,CAAC,sIAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AChDA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf,gBAAgB,mBAAO,CAAC,gDAAqB;AAC7C,mBAAmB,mBAAO,CAAC,kJAAoB;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;AC7GA;AACa;;AAEb,6BAA6B,mBAAO,CAAC,8JAA8C;AACnF,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,yBAAyB;AACzB,eAAe,mBAAO,CAAC,8CAAoB;AAC3C,eAAe,mBAAO,CAAC,8CAAoB;AAC3C,0CAA0C,mBAAO,CAAC,wKAAgB;AAClE,2CAA2C,mBAAO,CAAC,0KAAiB;AACpE,+CAA+C,mBAAO,CAAC,kLAAqB;AAC5E,qCAAqC,mBAAO,CAAC,4JAAU;AACvD,gDAAgD,mBAAO,CAAC,sLAAuB;AAC/E,oDAAoD,mBAAO,CAAC,8LAA2B;AACvF,2BAA2B,mBAAO,CAAC,0LAAyB;AAC5D;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;ACvCa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf,wBAAwB,mBAAO,CAAC,8JAA0B;AAC1D,qBAAqB,mBAAO,CAAC,sJAAsB;AACnD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sBAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACjPa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AClDa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACpDa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf,oBAAoB,mBAAO,CAAC,sJAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAe;AACf;;;;;;;;;;;ACvDa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf,mBAAmB;AACnB,eAAe,mBAAO,CAAC,8CAAoB;AAC3C,eAAe,mBAAO,CAAC,8CAAoB;AAC3C,YAAY,mBAAO,CAAC,wCAAiB;AACrC,cAAc,mBAAO,CAAC,mIAAW;AACjC,aAAa,mBAAO,CAAC,mIAAW;AAChC,oBAAoB,mBAAO,CAAC,mJAAmB;AAC/C,uBAAuB,mBAAO,CAAC,kKAAqB;AACpD,wBAAwB,mBAAO,CAAC,oKAAsB;AACtD,sBAAsB,mBAAO,CAAC,oKAAmB;AACjD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,4DAA4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9Ma;;AAEb,6BAA6B,mBAAO,CAAC,8JAA8C;AACnF,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB,eAAe,mBAAO,CAAC,8CAAoB;AAC3C,yCAAyC,mBAAO,CAAC,oDAAuB;AACxE,uBAAuB,mBAAO,CAAC,yJAAsB;AACrD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa,2CAA2C;AACxD;AACA,cAAc,4CAA4C;AAC1D,cAAc,kCAAkC;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,wBAAwB;AACnC;AACA,WAAW,wBAAwB;AACnC,WAAW,wBAAwB;AACnC;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;ACjFa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,iBAAiB;AACjB,eAAe,mBAAO,CAAC,8CAAoB;AAC3C,eAAe,mBAAO,CAAC,8CAAoB;AAC3C;AACA;AACA;;AAEA,cAAc,4CAA4C;AAC1D,cAAc,kCAAkC;;AAEhD;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,WAAW,aAAa;AACxB;AACA;AACA,YAAY,4CAA4C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA,WAAW,kBAAkB;AAC7B,YAAY,6CAA6C;AACzD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;AC7La;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,wBAAwB;AACxB,eAAe,mBAAO,CAAC,8CAAoB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,yCAAyC,iBAAiB;AAC1D,sCAAsC,SAAS;AAC/C,qBAAqB,WAAW,EAAE,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;AC5Da;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,uBAAuB;AACvB,eAAe,mBAAO,CAAC,8CAAoB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;AC/CA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc;AACd,iBAAiB;AACjB,wBAAwB,mBAAO,CAAC,wJAAqB;AACrD,cAAc,mBAAO,CAAC,kIAAU;AAChC;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Ca;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,cAAc;AACzB;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC/BA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB,cAAc;AACd,gCAAgC;AAChC,YAAY,mBAAO,CAAC,wCAAiB;AACrC,aAAa,mBAAO,CAAC,sIAAS;AAC9B,qBAAqB,mBAAO,CAAC,kJAAkB;AAC/C,cAAc,mBAAO,CAAC,kIAAU;AAChC,yBAAyB,mBAAO,CAAC,0JAAsB;AACvD,oBAAoB,mBAAO,CAAC,kJAAkB;AAC9C,sBAAsB,mBAAO,CAAC,sJAAoB;AAClD;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB,cAAc,sBAAsB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,cAAc,+BAA+B;AAC7C,cAAc,cAAc;AAC5B;AACA,kDAAkD;AAClD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C,cAAc,QAAQ;AACtB;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,IAAI;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,GAAG;AAClD;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B,EAAE,gDAAgD,EAAE,gBAAgB;AACrI;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9mBA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,uBAAuB;AACvB,wBAAwB,mBAAO,CAAC,0JAAsB;AACtD;AACA;AACA;;AAEA,cAAc,iCAAiC;AAC/C,cAAc,kCAAkC;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;AChCA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,wBAAwB;AACxB,qBAAqB,mBAAO,CAAC,oJAAmB;AAChD,cAAc,iCAAiC;AAC/C,cAAc,sCAAsC;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzFa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,uBAAuB;AACvB,yBAAyB,mBAAO,CAAC,0JAAsB;AACvD;AACA;AACA;;AAEA,cAAc,iCAAiC;AAC/C,cAAc,kCAAkC;;AAEhD;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChCa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,qBAAqB;AACrB,YAAY,mBAAO,CAAC,wCAAiB;AACrC,aAAa,mBAAO,CAAC,sIAAS;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,qDAAqD;;AAEnE;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,8BAA8B;AAC1C;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5Ba;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,sBAAsB;AACtB,yBAAyB,mBAAO,CAAC,0JAAsB;AACvD;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;;;;;;;;;;AC1Ba;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB,cAAc,mBAAO,CAAC,kIAAU;AAChC,yBAAyB,mBAAO,CAAC,0JAAsB;AACvD;AACA;AACA;;AAEA,cAAc,iCAAiC;AAC/C,cAAc,kCAAkC;;AAEhD;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnCa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc;AACd,cAAc,mBAAO,CAAC,kIAAU;AAChC,wBAAwB,mBAAO,CAAC,wJAAqB;AACrD;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,sBAAsB;AACjC,WAAW,sBAAsB;AACjC,WAAW,sBAAsB;AACjC;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;AC/Ca;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,mBAAmB;AACnB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9Ba;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,eAAe;AACf,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;;;;;;;;;;ACrBa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,qBAAqB;AACrB,cAAc,kCAAkC;;AAEhD;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzDa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnBA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,YAAY;AACZ,cAAc,mBAAO,CAAC,kIAAU;AAChC,wBAAwB,mBAAO,CAAC,wJAAqB;AACrD;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,sBAAsB;AACjC;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;ACzCA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,wBAAwB;AACxB,qBAAqB,mBAAO,CAAC,oJAAmB;AAChD;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1Ca;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,0BAA0B;AAC1B,YAAY,mBAAO,CAAC,wCAAiB;AACrC,aAAa,mBAAO,CAAC,sIAAS;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,eAAe;AAC7B;AACA,cAAc,eAAe;AAC7B;AACA,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B,cAAc,eAAe;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACA,YAAY,oBAAoB;AAChC,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,8BAA8B,mDAAmD,iBAAiB;AACxI;AACA;AACA,IAAI;AACJ;AACA;AACA,sCAAsC,4BAA4B,gDAAgD,mBAAmB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjGA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB,wBAAwB,mBAAO,CAAC,wJAAqB;AACrD;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;;;;;;;;;AC3Ea;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc;AACd,cAAc,mBAAO,CAAC,kIAAU;AAChC,cAAc,mBAAO,CAAC,kIAAU;AAChC;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3Ba;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,eAAe;AACf,wBAAwB,mBAAO,CAAC,wJAAqB;AACrD;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;ACtEa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,aAAa;AACb,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpCa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc,GAAG,oCAAoC;AACrD;AACA;AACA;AACA,qCAAqC,oCAAoC;;AAEzE;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;;;;;;;;;;;AChBA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,aAAa;AACb;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjFa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,sBAAsB;AACtB,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1Ca;;AAEb,6BAA6B,mBAAO,CAAC,8JAA8C;AACnF,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,aAAa;AACb,YAAY,mBAAO,CAAC,wCAAiB;AACrC,sCAAsC,mBAAO,CAAC,0IAAW;AACzD,wCAAwC,mBAAO,CAAC,8IAAa;AAC7D,sCAAsC,mBAAO,CAAC,0IAAW;AACzD,uCAAuC,+CAA+C,0CAA0C,kDAAkD,mBAAmB;AACrM,yCAAyC,uCAAuC,2EAA2E,cAAc,qCAAqC,oCAAoC,UAAU,iBAAiB,gEAAgE,0CAA0C,8BAA8B,0DAA0D,wEAAwE;AACvhB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;ACpCA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,kBAAe;AACf,mBAAmB;AACnB,YAAY,mBAAO,CAAC,wCAAiB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,YAAY,QAAQ;AACpB;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,KAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAe;AAC9B;AACA,CAAC;AACD;;;;;;;;;;;ACxCA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,qBAAqB;AACrB,mCAAmC;AACnC,iCAAiC;AACjC,sBAAsB;AACtB,YAAY,mBAAO,CAAC,wCAAiB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,yBAAyB;AACrC,YAAY,YAAY;AACxB;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA,uBAAuB,sBAAsB;;AAE7C;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,yBAAyB;AACrC,YAAY,YAAY;AACxB;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,wBAAwB,MAAM,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,yBAAyB;AACrC,YAAY,YAAY;AACxB;AACA;AACA,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAiD;AAC7E;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,yBAAyB;AACrC,YAAY,YAAY;AACxB;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iDAAiD;AAC7E;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,eAAe,kBAAkB,cAAc,WAAW;AAC1D,GAAG;AACH;AACA;;;;;;;;;;;AC1Ka;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,aAAa;AACb,sBAAsB;AACtB,kBAAkB;AAClB,aAAa;AACb,cAAc,mBAAO,CAAC,oIAAW;AACjC,qBAAqB,mBAAO,CAAC,kJAAkB;AAC/C,oBAAoB,mBAAO,CAAC,kJAAkB;AAC9C;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrSA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB,kBAAkB,mBAAO,CAAC,sDAAwB;AAClD,cAAc,mBAAO,CAAC,oIAAW;AACjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,mBAAmB,SAAS,SAAS,oBAAoB;AACzD,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,IAAI,kDAAkD;AACrF;AACA;AACA,eAAe,KAAK,EAAE,gBAAgB;AACtC;AACA,aAAa,KAAK,EAAE,gBAAgB,GAAG,6BAA6B,IAAI,KAAK;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;AC5HA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,cAAc;AACd,wBAAwB,mBAAO,CAAC,0JAAsB;AACtD,qBAAqB,mBAAO,CAAC,oJAAmB;AAChD,yBAAyB,mBAAO,CAAC,0JAAsB;AACvD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB,EAAE,wBAAwB;AACnF,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAiB,yBAAyB,sBAAsB,qBAAqB;AAC7H;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvSa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,oBAAoB;AACpB,YAAY,mBAAO,CAAC,wCAAiB;AACrC,YAAY,mBAAO,CAAC,wCAAiB;AACrC,uBAAuB,mBAAO,CAAC,wJAAqB;AACpD,oBAAoB,mBAAO,CAAC,gJAAiB;AAC7C,mBAAmB,mBAAO,CAAC,8IAAgB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,iCAAiC;AAC/C,cAAc,kCAAkC;;AAEhD;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9Ca;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,4BAA4B;AAC5B,YAAY,mBAAO,CAAC,wCAAiB;AACrC,aAAa,mBAAO,CAAC,sIAAS;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAc,2CAA2C;;AAEzD;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpCA;AACa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,qBAAqB;AACrB,qBAAqB,mBAAO,CAAC,oJAAmB;AAChD;AACA;AACA;;AAEA,cAAc,iCAAiC;;AAE/C;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B,WAAW,eAAe;AAC1B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC7DA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yBAAyB,SAAS,yBAAyB;;;;;;UCLpG;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;;ACtBa;;AAEb,8CAA6C;AAC7C;AACA,CAAC,EAAC;AACF,gDAA+C;AAC/C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,0DAAyD;AACzD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,2DAA0D;AAC1D;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,mDAAkD;AAClD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,yDAAwD;AACxD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,+CAA8C;AAC9C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,0CAAyC;AACzC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,0CAAyC;AACzC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,mDAAkD;AAClD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,oDAAmD;AACnD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,mDAAkD;AAClD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,kDAAiD;AACjD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,0CAAyC;AACzC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,gDAA+C;AAC/C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,+CAA8C;AAC9C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,2CAA0C;AAC1C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,wCAAuC;AACvC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,sDAAqD;AACrD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,0CAAyC;AACzC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,gDAA+C;AAC/C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,2CAA0C;AAC1C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,yCAAwC;AACxC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,yCAAwC;AACxC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,yCAAwC;AACxC;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,gDAA+C;AAC/C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,gDAA+C;AAC/C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,wDAAuD;AACvD;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,6CAA4C;AAC5C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,gDAA+C;AAC/C;AACA;AACA;AACA;AACA,CAAC,EAAC;AACF,aAAa,mBAAO,CAAC,sIAAS;AAC9B,mBAAmB,mBAAO,CAAC,8IAAgB;AAC3C,cAAc,mBAAO,CAAC,kIAAU;AAChC,cAAc,mBAAO,CAAC,kIAAU;AAChC,uBAAuB,mBAAO,CAAC,wJAAqB;AACpD,wBAAwB,mBAAO,CAAC,0JAAsB;AACtD,uBAAuB,mBAAO,CAAC,wJAAqB;AACpD,sBAAsB,mBAAO,CAAC,sJAAoB;AAClD,mBAAmB,mBAAO,CAAC,8IAAgB;AAC3C,eAAe,mBAAO,CAAC,sIAAY;AACnC,YAAY,mBAAO,CAAC,8HAAQ;AAC5B,0BAA0B,mBAAO,CAAC,8JAAwB;AAC1D,oBAAoB,mBAAO,CAAC,gJAAiB;AAC7C,cAAc,mBAAO,CAAC,kIAAU;AAChC,eAAe,mBAAO,CAAC,oIAAW;AAClC,cAAc,mBAAO,CAAC,kIAAU;AAChC,oBAAoB,mBAAO,CAAC,gJAAiB;AAC7C,aAAa,mBAAO,CAAC,gIAAS;AAC9B,aAAa,mBAAO,CAAC,gIAAS;AAC9B,aAAa,mBAAO,CAAC,kIAAU;AAC/B,oBAAoB,mBAAO,CAAC,kJAAkB;AAC9C,oBAAoB,mBAAO,CAAC,gJAAiB;AAC7C,4BAA4B,mBAAO,CAAC,kKAA0B;AAC9D,qBAAqB,mBAAO,CAAC,kJAAkB;AAC/C,oBAAoB,mBAAO,CAAC,sKAA4B;AACxD,iBAAiB,mBAAO,CAAC,8JAAwB;AACjD,yCAAyC,mBAAO,CAAC,8IAAa;AAC9D,uCAAuC,+CAA+C,0CAA0C,kDAAkD,mBAAmB;AACrM,yCAAyC,uCAAuC,2EAA2E,cAAc,qCAAqC,oCAAoC,UAAU,iBAAiB,gEAAgE,0CAA0C,8BAA8B,0DAA0D,wEAAwE;AACvhB,iC","sources":["webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/apply-format.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/event-listeners/copy-handler.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/event-listeners/delete.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/event-listeners/format-boundaries.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/event-listeners/index.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/event-listeners/input-and-selection.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/event-listeners/prevent-focus-capture.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/event-listeners/select-object.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/event-listeners/selection-change-compat.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/index.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/use-anchor-ref.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/use-anchor.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/use-boundary-style.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/component/use-default-style.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/concat.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/create-element.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/create.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/get-active-format.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/get-active-formats.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/get-active-object.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/get-format-type.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/get-text-content.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/insert-object.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/insert.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/is-collapsed.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/is-empty.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/is-format-equal.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/is-range-equal.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/join.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/normalise-formats.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/register-format-type.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/remove-format.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/remove.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/replace.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/slice.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/special-characters.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/split.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/store/actions.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/store/index.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/store/reducer.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/store/selectors.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/to-dom.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/to-html-string.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/to-tree.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/toggle-format.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/unregister-format-type.js","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/update-formats.js","webpack://wp.richText/external window [\"wp\",\"a11y\"]","webpack://wp.richText/external window [\"wp\",\"compose\"]","webpack://wp.richText/external window [\"wp\",\"data\"]","webpack://wp.richText/external window [\"wp\",\"deprecated\"]","webpack://wp.richText/external window [\"wp\",\"element\"]","webpack://wp.richText/external window [\"wp\",\"escapeHtml\"]","webpack://wp.richText/external window [\"wp\",\"i18n\"]","webpack://wp.richText/external window [\"wp\",\"keycodes\"]","webpack://wp.richText/../node_modules/.pnpm/@babel+runtime@7.25.7/node_modules/@babel/runtime/helpers/interopRequireDefault.js","webpack://wp.richText/webpack/bootstrap","webpack://wp.richText/../node_modules/.pnpm/@wordpress+rich-text@7.14.0_react@18.3.1/node_modules/@wordpress/rich-text/build/index.js"],"sourcesContent":["/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.applyFormat = applyFormat;\nvar _normaliseFormats = require(\"./normalise-formats\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\nfunction replace(array, index, value) {\n  array = array.slice();\n  array[index] = value;\n  return array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nfunction applyFormat(value, format, startIndex = value.start, endIndex = value.end) {\n  const {\n    formats,\n    activeFormats\n  } = value;\n  const newFormats = formats.slice();\n\n  // The selection is collapsed.\n  if (startIndex === endIndex) {\n    const startFormat = newFormats[startIndex]?.find(({\n      type\n    }) => type === format.type);\n\n    // If the caret is at a format of the same type, expand start and end to\n    // the edges of the format. This is useful to apply new attributes.\n    if (startFormat) {\n      const index = newFormats[startIndex].indexOf(startFormat);\n      while (newFormats[startIndex] && newFormats[startIndex][index] === startFormat) {\n        newFormats[startIndex] = replace(newFormats[startIndex], index, format);\n        startIndex--;\n      }\n      endIndex++;\n      while (newFormats[endIndex] && newFormats[endIndex][index] === startFormat) {\n        newFormats[endIndex] = replace(newFormats[endIndex], index, format);\n        endIndex++;\n      }\n    }\n  } else {\n    // Determine the highest position the new format can be inserted at.\n    let position = +Infinity;\n    for (let index = startIndex; index < endIndex; index++) {\n      if (newFormats[index]) {\n        newFormats[index] = newFormats[index].filter(({\n          type\n        }) => type !== format.type);\n        const length = newFormats[index].length;\n        if (length < position) {\n          position = length;\n        }\n      } else {\n        newFormats[index] = [];\n        position = 0;\n      }\n    }\n    for (let index = startIndex; index < endIndex; index++) {\n      newFormats[index].splice(position, 0, format);\n    }\n  }\n  return (0, _normaliseFormats.normaliseFormats)({\n    ...value,\n    formats: newFormats,\n    // Always revise active formats. This serves as a placeholder for new\n    // inputs with the format so new input appears with the format applied,\n    // and ensures a format of the same type uses the latest values.\n    activeFormats: [...(activeFormats?.filter(({\n      type\n    }) => type !== format.type) || []), format]\n  });\n}\n//# sourceMappingURL=apply-format.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _toHtmlString = require(\"../../to-html-string\");\nvar _isCollapsed = require(\"../../is-collapsed\");\nvar _slice = require(\"../../slice\");\nvar _getTextContent = require(\"../../get-text-content\");\n/**\n * Internal dependencies\n */\nvar _default = props => element => {\n  function onCopy(event) {\n    const {\n      record\n    } = props.current;\n    const {\n      ownerDocument\n    } = element;\n    if ((0, _isCollapsed.isCollapsed)(record.current) || !element.contains(ownerDocument.activeElement)) {\n      return;\n    }\n    const selectedRecord = (0, _slice.slice)(record.current);\n    const plainText = (0, _getTextContent.getTextContent)(selectedRecord);\n    const html = (0, _toHtmlString.toHTMLString)({\n      value: selectedRecord\n    });\n    event.clipboardData.setData('text/plain', plainText);\n    event.clipboardData.setData('text/html', html);\n    event.clipboardData.setData('rich-text', 'true');\n    event.preventDefault();\n    if (event.type === 'cut') {\n      ownerDocument.execCommand('delete');\n    }\n  }\n  const {\n    defaultView\n  } = element.ownerDocument;\n  defaultView.addEventListener('copy', onCopy);\n  defaultView.addEventListener('cut', onCopy);\n  return () => {\n    defaultView.removeEventListener('copy', onCopy);\n    defaultView.removeEventListener('cut', onCopy);\n  };\n};\nexports.default = _default;\n//# sourceMappingURL=copy-handler.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _keycodes = require(\"@wordpress/keycodes\");\nvar _remove = require(\"../../remove\");\n/**\n * WordPress dependencies\n */\n/**\n * Internal dependencies\n */\nvar _default = props => element => {\n  function onKeyDown(event) {\n    const {\n      keyCode\n    } = event;\n    const {\n      createRecord,\n      handleChange\n    } = props.current;\n    if (event.defaultPrevented) {\n      return;\n    }\n    if (keyCode !== _keycodes.DELETE && keyCode !== _keycodes.BACKSPACE) {\n      return;\n    }\n    const currentValue = createRecord();\n    const {\n      start,\n      end,\n      text\n    } = currentValue;\n\n    // Always handle full content deletion ourselves.\n    if (start === 0 && end !== 0 && end === text.length) {\n      handleChange((0, _remove.remove)(currentValue));\n      event.preventDefault();\n    }\n  }\n  element.addEventListener('keydown', onKeyDown);\n  return () => {\n    element.removeEventListener('keydown', onKeyDown);\n  };\n};\nexports.default = _default;\n//# sourceMappingURL=delete.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _keycodes = require(\"@wordpress/keycodes\");\nvar _isCollapsed = require(\"../../is-collapsed\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\nconst EMPTY_ACTIVE_FORMATS = [];\nvar _default = props => element => {\n  function onKeyDown(event) {\n    const {\n      keyCode,\n      shiftKey,\n      altKey,\n      metaKey,\n      ctrlKey\n    } = event;\n    if (\n    // Only override left and right keys without modifiers pressed.\n    shiftKey || altKey || metaKey || ctrlKey || keyCode !== _keycodes.LEFT && keyCode !== _keycodes.RIGHT) {\n      return;\n    }\n    const {\n      record,\n      applyRecord,\n      forceRender\n    } = props.current;\n    const {\n      text,\n      formats,\n      start,\n      end,\n      activeFormats: currentActiveFormats = []\n    } = record.current;\n    const collapsed = (0, _isCollapsed.isCollapsed)(record.current);\n    const {\n      ownerDocument\n    } = element;\n    const {\n      defaultView\n    } = ownerDocument;\n    // To do: ideally, we should look at visual position instead.\n    const {\n      direction\n    } = defaultView.getComputedStyle(element);\n    const reverseKey = direction === 'rtl' ? _keycodes.RIGHT : _keycodes.LEFT;\n    const isReverse = event.keyCode === reverseKey;\n\n    // If the selection is collapsed and at the very start, do nothing if\n    // navigating backward.\n    // If the selection is collapsed and at the very end, do nothing if\n    // navigating forward.\n    if (collapsed && currentActiveFormats.length === 0) {\n      if (start === 0 && isReverse) {\n        return;\n      }\n      if (end === text.length && !isReverse) {\n        return;\n      }\n    }\n\n    // If the selection is not collapsed, let the browser handle collapsing\n    // the selection for now. Later we could expand this logic to set\n    // boundary positions if needed.\n    if (!collapsed) {\n      return;\n    }\n    const formatsBefore = formats[start - 1] || EMPTY_ACTIVE_FORMATS;\n    const formatsAfter = formats[start] || EMPTY_ACTIVE_FORMATS;\n    const destination = isReverse ? formatsBefore : formatsAfter;\n    const isIncreasing = currentActiveFormats.every((format, index) => format === destination[index]);\n    let newActiveFormatsLength = currentActiveFormats.length;\n    if (!isIncreasing) {\n      newActiveFormatsLength--;\n    } else if (newActiveFormatsLength < destination.length) {\n      newActiveFormatsLength++;\n    }\n    if (newActiveFormatsLength === currentActiveFormats.length) {\n      record.current._newActiveFormats = destination;\n      return;\n    }\n    event.preventDefault();\n    const origin = isReverse ? formatsAfter : formatsBefore;\n    const source = isIncreasing ? destination : origin;\n    const newActiveFormats = source.slice(0, newActiveFormatsLength);\n    const newValue = {\n      ...record.current,\n      activeFormats: newActiveFormats\n    };\n    record.current = newValue;\n    applyRecord(newValue);\n    forceRender();\n  }\n  element.addEventListener('keydown', onKeyDown);\n  return () => {\n    element.removeEventListener('keydown', onKeyDown);\n  };\n};\nexports.default = _default;\n//# sourceMappingURL=format-boundaries.js.map","/* wp:polyfill */\n\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useEventListeners = useEventListeners;\nvar _element = require(\"@wordpress/element\");\nvar _compose = require(\"@wordpress/compose\");\nvar _copyHandler = _interopRequireDefault(require(\"./copy-handler\"));\nvar _selectObject = _interopRequireDefault(require(\"./select-object\"));\nvar _formatBoundaries = _interopRequireDefault(require(\"./format-boundaries\"));\nvar _delete = _interopRequireDefault(require(\"./delete\"));\nvar _inputAndSelection = _interopRequireDefault(require(\"./input-and-selection\"));\nvar _selectionChangeCompat = _interopRequireDefault(require(\"./selection-change-compat\"));\nvar _preventFocusCapture = require(\"./prevent-focus-capture\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\nconst allEventListeners = [_copyHandler.default, _selectObject.default, _formatBoundaries.default, _delete.default, _inputAndSelection.default, _selectionChangeCompat.default, _preventFocusCapture.preventFocusCapture];\nfunction useEventListeners(props) {\n  const propsRef = (0, _element.useRef)(props);\n  (0, _element.useInsertionEffect)(() => {\n    propsRef.current = props;\n  });\n  const refEffects = (0, _element.useMemo)(() => allEventListeners.map(refEffect => refEffect(propsRef)), [propsRef]);\n  return (0, _compose.useRefEffect)(element => {\n    const cleanups = refEffects.map(effect => effect(element));\n    return () => {\n      cleanups.forEach(cleanup => cleanup());\n    };\n  }, [refEffects]);\n}\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _getActiveFormats = require(\"../../get-active-formats\");\nvar _updateFormats = require(\"../../update-formats\");\n/**\n * Internal dependencies\n */\n\n/**\n * All inserting input types that would insert HTML into the DOM.\n *\n * @see https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes\n *\n * @type {Set}\n */\nconst INSERTION_INPUT_TYPES_TO_IGNORE = new Set(['insertParagraph', 'insertOrderedList', 'insertUnorderedList', 'insertHorizontalRule', 'insertLink']);\nconst EMPTY_ACTIVE_FORMATS = [];\nconst PLACEHOLDER_ATTR_NAME = 'data-rich-text-placeholder';\n\n/**\n * If the selection is set on the placeholder element, collapse the selection to\n * the start (before the placeholder).\n *\n * @param {Window} defaultView\n */\nfunction fixPlaceholderSelection(defaultView) {\n  const selection = defaultView.getSelection();\n  const {\n    anchorNode,\n    anchorOffset\n  } = selection;\n  if (anchorNode.nodeType !== anchorNode.ELEMENT_NODE) {\n    return;\n  }\n  const targetNode = anchorNode.childNodes[anchorOffset];\n  if (!targetNode || targetNode.nodeType !== targetNode.ELEMENT_NODE || !targetNode.hasAttribute(PLACEHOLDER_ATTR_NAME)) {\n    return;\n  }\n  selection.collapseToStart();\n}\nvar _default = props => element => {\n  const {\n    ownerDocument\n  } = element;\n  const {\n    defaultView\n  } = ownerDocument;\n  let isComposing = false;\n  function onInput(event) {\n    // Do not trigger a change if characters are being composed. Browsers\n    // will usually emit a final `input` event when the characters are\n    // composed. As of December 2019, Safari doesn't support\n    // nativeEvent.isComposing.\n    if (isComposing) {\n      return;\n    }\n    let inputType;\n    if (event) {\n      inputType = event.inputType;\n    }\n    const {\n      record,\n      applyRecord,\n      createRecord,\n      handleChange\n    } = props.current;\n\n    // The browser formatted something or tried to insert HTML. Overwrite\n    // it. It will be handled later by the format library if needed.\n    if (inputType && (inputType.indexOf('format') === 0 || INSERTION_INPUT_TYPES_TO_IGNORE.has(inputType))) {\n      applyRecord(record.current);\n      return;\n    }\n    const currentValue = createRecord();\n    const {\n      start,\n      activeFormats: oldActiveFormats = []\n    } = record.current;\n\n    // Update the formats between the last and new caret position.\n    const change = (0, _updateFormats.updateFormats)({\n      value: currentValue,\n      start,\n      end: currentValue.start,\n      formats: oldActiveFormats\n    });\n    handleChange(change);\n  }\n\n  /**\n   * Syncs the selection to local state. A callback for the `selectionchange`\n   * event.\n   */\n  function handleSelectionChange() {\n    const {\n      record,\n      applyRecord,\n      createRecord,\n      onSelectionChange\n    } = props.current;\n\n    // Check if the implementor disabled editing. `contentEditable` does\n    // disable input, but not text selection, so we must ignore selection\n    // changes.\n    if (element.contentEditable !== 'true') {\n      return;\n    }\n\n    // Ensure the active element is the rich text element.\n    if (ownerDocument.activeElement !== element) {\n      // If it is not, we can stop listening for selection changes. We\n      // resume listening when the element is focused.\n      ownerDocument.removeEventListener('selectionchange', handleSelectionChange);\n      return;\n    }\n\n    // In case of a keyboard event, ignore selection changes during\n    // composition.\n    if (isComposing) {\n      return;\n    }\n    const {\n      start,\n      end,\n      text\n    } = createRecord();\n    const oldRecord = record.current;\n\n    // Fallback mechanism for IE11, which doesn't support the input event.\n    // Any input results in a selection change.\n    if (text !== oldRecord.text) {\n      onInput();\n      return;\n    }\n    if (start === oldRecord.start && end === oldRecord.end) {\n      // Sometimes the browser may set the selection on the placeholder\n      // element, in which case the caret is not visible. We need to set\n      // the caret before the placeholder if that's the case.\n      if (oldRecord.text.length === 0 && start === 0) {\n        fixPlaceholderSelection(defaultView);\n      }\n      return;\n    }\n    const newValue = {\n      ...oldRecord,\n      start,\n      end,\n      // _newActiveFormats may be set on arrow key navigation to control\n      // the right boundary position. If undefined, getActiveFormats will\n      // give the active formats according to the browser.\n      activeFormats: oldRecord._newActiveFormats,\n      _newActiveFormats: undefined\n    };\n    const newActiveFormats = (0, _getActiveFormats.getActiveFormats)(newValue, EMPTY_ACTIVE_FORMATS);\n\n    // Update the value with the new active formats.\n    newValue.activeFormats = newActiveFormats;\n\n    // It is important that the internal value is updated first,\n    // otherwise the value will be wrong on render!\n    record.current = newValue;\n    applyRecord(newValue, {\n      domOnly: true\n    });\n    onSelectionChange(start, end);\n  }\n  function onCompositionStart() {\n    isComposing = true;\n    // Do not update the selection when characters are being composed as\n    // this rerenders the component and might destroy internal browser\n    // editing state.\n    ownerDocument.removeEventListener('selectionchange', handleSelectionChange);\n    // Remove the placeholder. Since the rich text value doesn't update\n    // during composition, the placeholder doesn't get removed. There's no\n    // need to re-add it, when the value is updated on compositionend it\n    // will be re-added when the value is empty.\n    element.querySelector(`[${PLACEHOLDER_ATTR_NAME}]`)?.remove();\n  }\n  function onCompositionEnd() {\n    isComposing = false;\n    // Ensure the value is up-to-date for browsers that don't emit a final\n    // input event after composition.\n    onInput({\n      inputType: 'insertText'\n    });\n    // Tracking selection changes can be resumed.\n    ownerDocument.addEventListener('selectionchange', handleSelectionChange);\n  }\n  function onFocus() {\n    const {\n      record,\n      isSelected,\n      onSelectionChange,\n      applyRecord\n    } = props.current;\n\n    // When the whole editor is editable, let writing flow handle\n    // selection.\n    if (element.parentElement.closest('[contenteditable=\"true\"]')) {\n      return;\n    }\n    if (!isSelected) {\n      // We know for certain that on focus, the old selection is invalid.\n      // It will be recalculated on the next mouseup, keyup, or touchend\n      // event.\n      const index = undefined;\n      record.current = {\n        ...record.current,\n        start: index,\n        end: index,\n        activeFormats: EMPTY_ACTIVE_FORMATS\n      };\n    } else {\n      applyRecord(record.current, {\n        domOnly: true\n      });\n    }\n    onSelectionChange(record.current.start, record.current.end);\n\n    // There is no selection change event when the element is focused, so\n    // we need to manually trigger it. The selection is also not available\n    // yet in this call stack.\n    window.queueMicrotask(handleSelectionChange);\n    ownerDocument.addEventListener('selectionchange', handleSelectionChange);\n  }\n  element.addEventListener('input', onInput);\n  element.addEventListener('compositionstart', onCompositionStart);\n  element.addEventListener('compositionend', onCompositionEnd);\n  element.addEventListener('focus', onFocus);\n  return () => {\n    element.removeEventListener('input', onInput);\n    element.removeEventListener('compositionstart', onCompositionStart);\n    element.removeEventListener('compositionend', onCompositionEnd);\n    element.removeEventListener('focus', onFocus);\n  };\n};\nexports.default = _default;\n//# sourceMappingURL=input-and-selection.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preventFocusCapture = preventFocusCapture;\n/**\n * Prevents focus from being captured by the element when clicking _outside_\n * around the element. This may happen when the parent element is flex.\n * @see https://github.com/WordPress/gutenberg/pull/65857\n * @see https://github.com/WordPress/gutenberg/pull/66402\n */\nfunction preventFocusCapture() {\n  return element => {\n    const {\n      ownerDocument\n    } = element;\n    const {\n      defaultView\n    } = ownerDocument;\n    let value = null;\n    function onPointerDown(event) {\n      // Abort if the event is default prevented, we will not get a pointer up event.\n      if (event.defaultPrevented) {\n        return;\n      }\n      if (event.target === element) {\n        return;\n      }\n      if (!event.target.contains(element)) {\n        return;\n      }\n      value = element.getAttribute('contenteditable');\n      element.setAttribute('contenteditable', 'false');\n      defaultView.getSelection().removeAllRanges();\n    }\n    function onPointerUp() {\n      if (value !== null) {\n        element.setAttribute('contenteditable', value);\n        value = null;\n      }\n    }\n    defaultView.addEventListener('pointerdown', onPointerDown);\n    defaultView.addEventListener('pointerup', onPointerUp);\n    return () => {\n      defaultView.removeEventListener('pointerdown', onPointerDown);\n      defaultView.removeEventListener('pointerup', onPointerUp);\n    };\n  };\n}\n//# sourceMappingURL=prevent-focus-capture.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = () => element => {\n  function onClick(event) {\n    const {\n      target\n    } = event;\n\n    // If the child element has no text content, it must be an object.\n    if (target === element || target.textContent && target.isContentEditable) {\n      return;\n    }\n    const {\n      ownerDocument\n    } = target;\n    const {\n      defaultView\n    } = ownerDocument;\n    const selection = defaultView.getSelection();\n\n    // If it's already selected, do nothing and let default behavior happen.\n    // This means it's \"click-through\".\n    if (selection.containsNode(target)) {\n      return;\n    }\n    const range = ownerDocument.createRange();\n    // If the target is within a non editable element, select the non\n    // editable element.\n    const nodeToSelect = target.isContentEditable ? target : target.closest('[contenteditable]');\n    range.selectNode(nodeToSelect);\n    selection.removeAllRanges();\n    selection.addRange(range);\n    event.preventDefault();\n  }\n  function onFocusIn(event) {\n    // When there is incoming focus from a link, select the object.\n    if (event.relatedTarget && !element.contains(event.relatedTarget) && event.relatedTarget.tagName === 'A') {\n      onClick(event);\n    }\n  }\n  element.addEventListener('click', onClick);\n  element.addEventListener('focusin', onFocusIn);\n  return () => {\n    element.removeEventListener('click', onClick);\n    element.removeEventListener('focusin', onFocusIn);\n  };\n};\nexports.default = _default;\n//# sourceMappingURL=select-object.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isRangeEqual = require(\"../../is-range-equal\");\n/**\n * Internal dependencies\n */\n/**\n * Sometimes some browsers are not firing a `selectionchange` event when\n * changing the selection by mouse or keyboard. This hook makes sure that, if we\n * detect no `selectionchange` or `input` event between the up and down events,\n * we fire a `selectionchange` event.\n */\nvar _default = () => element => {\n  const {\n    ownerDocument\n  } = element;\n  const {\n    defaultView\n  } = ownerDocument;\n  const selection = defaultView?.getSelection();\n  let range;\n  function getRange() {\n    return selection.rangeCount ? selection.getRangeAt(0) : null;\n  }\n  function onDown(event) {\n    const type = event.type === 'keydown' ? 'keyup' : 'pointerup';\n    function onCancel() {\n      ownerDocument.removeEventListener(type, onUp);\n      ownerDocument.removeEventListener('selectionchange', onCancel);\n      ownerDocument.removeEventListener('input', onCancel);\n    }\n    function onUp() {\n      onCancel();\n      if ((0, _isRangeEqual.isRangeEqual)(range, getRange())) {\n        return;\n      }\n      ownerDocument.dispatchEvent(new Event('selectionchange'));\n    }\n    ownerDocument.addEventListener(type, onUp);\n    ownerDocument.addEventListener('selectionchange', onCancel);\n    ownerDocument.addEventListener('input', onCancel);\n    range = getRange();\n  }\n  element.addEventListener('pointerdown', onDown);\n  element.addEventListener('keydown', onDown);\n  return () => {\n    element.removeEventListener('pointerdown', onDown);\n    element.removeEventListener('keydown', onDown);\n  };\n};\nexports.default = _default;\n//# sourceMappingURL=selection-change-compat.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = __experimentalRichText;\nexports.useRichText = useRichText;\nvar _element = require(\"@wordpress/element\");\nvar _compose = require(\"@wordpress/compose\");\nvar _data = require(\"@wordpress/data\");\nvar _create = require(\"../create\");\nvar _toDom = require(\"../to-dom\");\nvar _toHtmlString = require(\"../to-html-string\");\nvar _useDefaultStyle = require(\"./use-default-style\");\nvar _useBoundaryStyle = require(\"./use-boundary-style\");\nvar _eventListeners = require(\"./event-listeners\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\nfunction useRichText({\n  value = '',\n  selectionStart,\n  selectionEnd,\n  placeholder,\n  onSelectionChange,\n  preserveWhiteSpace,\n  onChange,\n  __unstableDisableFormats: disableFormats,\n  __unstableIsSelected: isSelected,\n  __unstableDependencies = [],\n  __unstableAfterParse,\n  __unstableBeforeSerialize,\n  __unstableAddInvisibleFormats\n}) {\n  const registry = (0, _data.useRegistry)();\n  const [, forceRender] = (0, _element.useReducer)(() => ({}));\n  const ref = (0, _element.useRef)();\n  function createRecord() {\n    const {\n      ownerDocument: {\n        defaultView\n      }\n    } = ref.current;\n    const selection = defaultView.getSelection();\n    const range = selection.rangeCount > 0 ? selection.getRangeAt(0) : null;\n    return (0, _create.create)({\n      element: ref.current,\n      range,\n      __unstableIsEditableTree: true\n    });\n  }\n  function applyRecord(newRecord, {\n    domOnly\n  } = {}) {\n    (0, _toDom.apply)({\n      value: newRecord,\n      current: ref.current,\n      prepareEditableTree: __unstableAddInvisibleFormats,\n      __unstableDomOnly: domOnly,\n      placeholder\n    });\n  }\n\n  // Internal values are updated synchronously, unlike props and state.\n  const _valueRef = (0, _element.useRef)(value);\n  const recordRef = (0, _element.useRef)();\n  function setRecordFromProps() {\n    _valueRef.current = value;\n    recordRef.current = value;\n    if (!(value instanceof _create.RichTextData)) {\n      recordRef.current = value ? _create.RichTextData.fromHTMLString(value, {\n        preserveWhiteSpace\n      }) : _create.RichTextData.empty();\n    }\n    // To do: make rich text internally work with RichTextData.\n    recordRef.current = {\n      text: recordRef.current.text,\n      formats: recordRef.current.formats,\n      replacements: recordRef.current.replacements\n    };\n    if (disableFormats) {\n      recordRef.current.formats = Array(value.length);\n      recordRef.current.replacements = Array(value.length);\n    }\n    if (__unstableAfterParse) {\n      recordRef.current.formats = __unstableAfterParse(recordRef.current);\n    }\n    recordRef.current.start = selectionStart;\n    recordRef.current.end = selectionEnd;\n  }\n  const hadSelectionUpdateRef = (0, _element.useRef)(false);\n  if (!recordRef.current) {\n    hadSelectionUpdateRef.current = isSelected;\n    setRecordFromProps();\n  } else if (selectionStart !== recordRef.current.start || selectionEnd !== recordRef.current.end) {\n    hadSelectionUpdateRef.current = isSelected;\n    recordRef.current = {\n      ...recordRef.current,\n      start: selectionStart,\n      end: selectionEnd,\n      activeFormats: undefined\n    };\n  }\n\n  /**\n   * Sync the value to global state. The node tree and selection will also be\n   * updated if differences are found.\n   *\n   * @param {Object} newRecord The record to sync and apply.\n   */\n  function handleChange(newRecord) {\n    recordRef.current = newRecord;\n    applyRecord(newRecord);\n    if (disableFormats) {\n      _valueRef.current = newRecord.text;\n    } else {\n      const newFormats = __unstableBeforeSerialize ? __unstableBeforeSerialize(newRecord) : newRecord.formats;\n      newRecord = {\n        ...newRecord,\n        formats: newFormats\n      };\n      if (typeof value === 'string') {\n        _valueRef.current = (0, _toHtmlString.toHTMLString)({\n          value: newRecord,\n          preserveWhiteSpace\n        });\n      } else {\n        _valueRef.current = new _create.RichTextData(newRecord);\n      }\n    }\n    const {\n      start,\n      end,\n      formats,\n      text\n    } = recordRef.current;\n\n    // Selection must be updated first, so it is recorded in history when\n    // the content change happens.\n    // We batch both calls to only attempt to rerender once.\n    registry.batch(() => {\n      onSelectionChange(start, end);\n      onChange(_valueRef.current, {\n        __unstableFormats: formats,\n        __unstableText: text\n      });\n    });\n    forceRender();\n  }\n  function applyFromProps() {\n    setRecordFromProps();\n    applyRecord(recordRef.current);\n  }\n  const didMountRef = (0, _element.useRef)(false);\n\n  // Value updates must happen synchonously to avoid overwriting newer values.\n  (0, _element.useLayoutEffect)(() => {\n    if (didMountRef.current && value !== _valueRef.current) {\n      applyFromProps();\n      forceRender();\n    }\n  }, [value]);\n\n  // Value updates must happen synchonously to avoid overwriting newer values.\n  (0, _element.useLayoutEffect)(() => {\n    if (!hadSelectionUpdateRef.current) {\n      return;\n    }\n    if (ref.current.ownerDocument.activeElement !== ref.current) {\n      ref.current.focus();\n    }\n    applyRecord(recordRef.current);\n    hadSelectionUpdateRef.current = false;\n  }, [hadSelectionUpdateRef.current]);\n  const mergedRefs = (0, _compose.useMergeRefs)([ref, (0, _useDefaultStyle.useDefaultStyle)(), (0, _useBoundaryStyle.useBoundaryStyle)({\n    record: recordRef\n  }), (0, _eventListeners.useEventListeners)({\n    record: recordRef,\n    handleChange,\n    applyRecord,\n    createRecord,\n    isSelected,\n    onSelectionChange,\n    forceRender\n  }), (0, _compose.useRefEffect)(() => {\n    applyFromProps();\n    didMountRef.current = true;\n  }, [placeholder, ...__unstableDependencies])]);\n  return {\n    value: recordRef.current,\n    // A function to get the most recent value so event handlers in\n    // useRichText implementations have access to it. For example when\n    // listening to input events, we internally update the state, but this\n    // state is not yet available to the input event handler because React\n    // may re-render asynchronously.\n    getValue: () => recordRef.current,\n    onChange: handleChange,\n    ref: mergedRefs\n  };\n}\nfunction __experimentalRichText() {}\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useAnchorRef = useAnchorRef;\nvar _element = require(\"@wordpress/element\");\nvar _deprecated = _interopRequireDefault(require(\"@wordpress/deprecated\"));\nvar _getActiveFormat = require(\"../get-active-format\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\n/**\n * @template T\n * @typedef {import('@wordpress/element').RefObject<T>} RefObject<T>\n */\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or the selection range if no format is active.\n * The returned value is meant to be used for positioning UI, e.g. by passing it\n * to the `Popover` component.\n *\n * @param {Object}                 $1          Named parameters.\n * @param {RefObject<HTMLElement>} $1.ref      React ref of the element\n *                                             containing  the editable content.\n * @param {RichTextValue}          $1.value    Value to check for selection.\n * @param {WPFormat}               $1.settings The format type's settings.\n *\n * @return {Element|Range} The active element or selection range.\n */\nfunction useAnchorRef({\n  ref,\n  value,\n  settings = {}\n}) {\n  (0, _deprecated.default)('`useAnchorRef` hook', {\n    since: '6.1',\n    alternative: '`useAnchor` hook'\n  });\n  const {\n    tagName,\n    className,\n    name\n  } = settings;\n  const activeFormat = name ? (0, _getActiveFormat.getActiveFormat)(value, name) : undefined;\n  return (0, _element.useMemo)(() => {\n    if (!ref.current) {\n      return;\n    }\n    const {\n      ownerDocument: {\n        defaultView\n      }\n    } = ref.current;\n    const selection = defaultView.getSelection();\n    if (!selection.rangeCount) {\n      return;\n    }\n    const range = selection.getRangeAt(0);\n    if (!activeFormat) {\n      return range;\n    }\n    let element = range.startContainer;\n\n    // If the caret is right before the element, select the next element.\n    element = element.nextElementSibling || element;\n    while (element.nodeType !== element.ELEMENT_NODE) {\n      element = element.parentNode;\n    }\n    return element.closest(tagName + (className ? '.' + className : ''));\n  }, [activeFormat, value.start, value.end, tagName, className]);\n}\n//# sourceMappingURL=use-anchor-ref.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useAnchor = useAnchor;\nvar _compose = require(\"@wordpress/compose\");\nvar _element = require(\"@wordpress/element\");\n/**\n * WordPress dependencies\n */\n\n/** @typedef {import('../register-format-type').WPFormat} WPFormat */\n/** @typedef {import('../types').RichTextValue} RichTextValue */\n\n/**\n * Given a range and a format tag name and class name, returns the closest\n * format element.\n *\n * @param {Range}       range                  The Range to check.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format element.\n * @param {string}      className              The class name of the format element.\n *\n * @return {HTMLElement|undefined} The format element, if found.\n */\nfunction getFormatElement(range, editableContentElement, tagName, className) {\n  let element = range.startContainer;\n\n  // Even if the active format is defined, the actualy DOM range's start\n  // container may be outside of the format's DOM element:\n  // `a<strong>b</strong>` (DOM) while visually it's `a<strong>b</strong>`.\n  // So at a given selection index, start with the deepest format DOM element.\n  if (element.nodeType === element.TEXT_NODE && range.startOffset === element.length && element.nextSibling) {\n    element = element.nextSibling;\n    while (element.firstChild) {\n      element = element.firstChild;\n    }\n  }\n  if (element.nodeType !== element.ELEMENT_NODE) {\n    element = element.parentElement;\n  }\n  if (!element) {\n    return;\n  }\n  if (element === editableContentElement) {\n    return;\n  }\n  if (!editableContentElement.contains(element)) {\n    return;\n  }\n  const selector = tagName + (className ? '.' + className : '');\n\n  // .closest( selector ), but with a boundary. Check if the element matches\n  // the selector. If it doesn't match, try the parent element if it's not the\n  // editable wrapper. We don't want to try to match ancestors of the editable\n  // wrapper, which is what .closest( selector ) would do. When the element is\n  // the editable wrapper (which is most likely the case because most text is\n  // unformatted), this never runs.\n  while (element !== editableContentElement) {\n    if (element.matches(selector)) {\n      return element;\n    }\n    element = element.parentElement;\n  }\n}\n\n/**\n * @typedef {Object} VirtualAnchorElement\n * @property {() => DOMRect} getBoundingClientRect A function returning a DOMRect\n * @property {HTMLElement}   contextElement        The actual DOM element\n */\n\n/**\n * Creates a virtual anchor element for a range.\n *\n * @param {Range}       range                  The range to create a virtual anchor element for.\n * @param {HTMLElement} editableContentElement The editable wrapper.\n *\n * @return {VirtualAnchorElement} The virtual anchor element.\n */\nfunction createVirtualAnchorElement(range, editableContentElement) {\n  return {\n    contextElement: editableContentElement,\n    getBoundingClientRect() {\n      return editableContentElement.contains(range.startContainer) ? range.getBoundingClientRect() : editableContentElement.getBoundingClientRect();\n    }\n  };\n}\n\n/**\n * Get the anchor: a format element if there is a matching one based on the\n * tagName and className or a range otherwise.\n *\n * @param {HTMLElement} editableContentElement The editable wrapper.\n * @param {string}      tagName                The tag name of the format\n *                                             element.\n * @param {string}      className              The class name of the format\n *                                             element.\n *\n * @return {HTMLElement|VirtualAnchorElement|undefined} The anchor.\n */\nfunction getAnchor(editableContentElement, tagName, className) {\n  if (!editableContentElement) {\n    return;\n  }\n  const {\n    ownerDocument\n  } = editableContentElement;\n  const {\n    defaultView\n  } = ownerDocument;\n  const selection = defaultView.getSelection();\n  if (!selection) {\n    return;\n  }\n  if (!selection.rangeCount) {\n    return;\n  }\n  const range = selection.getRangeAt(0);\n  if (!range || !range.startContainer) {\n    return;\n  }\n  const formatElement = getFormatElement(range, editableContentElement, tagName, className);\n  if (formatElement) {\n    return formatElement;\n  }\n  return createVirtualAnchorElement(range, editableContentElement);\n}\n\n/**\n * This hook, to be used in a format type's Edit component, returns the active\n * element that is formatted, or a virtual element for the selection range if\n * no format is active. The returned value is meant to be used for positioning\n * UI, e.g. by passing it to the `Popover` component via the `anchor` prop.\n *\n * @param {Object}           $1                        Named parameters.\n * @param {HTMLElement|null} $1.editableContentElement The element containing\n *                                                     the editable content.\n * @param {WPFormat=}        $1.settings               The format type's settings.\n * @return {Element|VirtualAnchorElement|undefined|null} The active element or selection range.\n */\nfunction useAnchor({\n  editableContentElement,\n  settings = {}\n}) {\n  const {\n    tagName,\n    className,\n    isActive\n  } = settings;\n  const [anchor, setAnchor] = (0, _element.useState)(() => getAnchor(editableContentElement, tagName, className));\n  const wasActive = (0, _compose.usePrevious)(isActive);\n  (0, _element.useLayoutEffect)(() => {\n    if (!editableContentElement) {\n      return;\n    }\n    function callback() {\n      setAnchor(getAnchor(editableContentElement, tagName, className));\n    }\n    function attach() {\n      ownerDocument.addEventListener('selectionchange', callback);\n    }\n    function detach() {\n      ownerDocument.removeEventListener('selectionchange', callback);\n    }\n    const {\n      ownerDocument\n    } = editableContentElement;\n    if (editableContentElement === ownerDocument.activeElement ||\n    // When a link is created, we need to attach the popover to the newly created anchor.\n    !wasActive && isActive ||\n    // Sometimes we're _removing_ an active anchor, such as the inline color popover.\n    // When we add the color, it switches from a virtual anchor to a `<mark>` element.\n    // When we _remove_ the color, it switches from a `<mark>` element to a virtual anchor.\n    wasActive && !isActive) {\n      setAnchor(getAnchor(editableContentElement, tagName, className));\n      attach();\n    }\n    editableContentElement.addEventListener('focusin', attach);\n    editableContentElement.addEventListener('focusout', detach);\n    return () => {\n      detach();\n      editableContentElement.removeEventListener('focusin', attach);\n      editableContentElement.removeEventListener('focusout', detach);\n    };\n  }, [editableContentElement, tagName, className, isActive, wasActive]);\n  return anchor;\n}\n//# sourceMappingURL=use-anchor.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useBoundaryStyle = useBoundaryStyle;\nvar _element = require(\"@wordpress/element\");\n/**\n * WordPress dependencies\n */\n\n/*\n * Calculates and renders the format boundary style when the active formats\n * change.\n */\nfunction useBoundaryStyle({\n  record\n}) {\n  const ref = (0, _element.useRef)();\n  const {\n    activeFormats = [],\n    replacements,\n    start\n  } = record.current;\n  const activeReplacement = replacements[start];\n  (0, _element.useEffect)(() => {\n    // There's no need to recalculate the boundary styles if no formats are\n    // active, because no boundary styles will be visible.\n    if ((!activeFormats || !activeFormats.length) && !activeReplacement) {\n      return;\n    }\n    const boundarySelector = '*[data-rich-text-format-boundary]';\n    const element = ref.current.querySelector(boundarySelector);\n    if (!element) {\n      return;\n    }\n    const {\n      ownerDocument\n    } = element;\n    const {\n      defaultView\n    } = ownerDocument;\n    const computedStyle = defaultView.getComputedStyle(element);\n    const newColor = computedStyle.color.replace(')', ', 0.2)').replace('rgb', 'rgba');\n    const selector = `.rich-text:focus ${boundarySelector}`;\n    const rule = `background-color: ${newColor}`;\n    const style = `${selector} {${rule}}`;\n    const globalStyleId = 'rich-text-boundary-style';\n    let globalStyle = ownerDocument.getElementById(globalStyleId);\n    if (!globalStyle) {\n      globalStyle = ownerDocument.createElement('style');\n      globalStyle.id = globalStyleId;\n      ownerDocument.head.appendChild(globalStyle);\n    }\n    if (globalStyle.innerHTML !== style) {\n      globalStyle.innerHTML = style;\n    }\n  }, [activeFormats, activeReplacement]);\n  return ref;\n}\n//# sourceMappingURL=use-boundary-style.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.useDefaultStyle = useDefaultStyle;\nvar _element = require(\"@wordpress/element\");\n/**\n * WordPress dependencies\n */\n\n/**\n * In HTML, leading and trailing spaces are not visible, and multiple spaces\n * elsewhere are visually reduced to one space. This rule prevents spaces from\n * collapsing so all space is visible in the editor and can be removed. It also\n * prevents some browsers from inserting non-breaking spaces at the end of a\n * line to prevent the space from visually disappearing. Sometimes these non\n * breaking spaces can linger in the editor causing unwanted non breaking spaces\n * in between words. If also prevent Firefox from inserting a trailing `br` node\n * to visualise any trailing space, causing the element to be saved.\n *\n * > Authors are encouraged to set the 'white-space' property on editing hosts\n * > and on markup that was originally created through these editing mechanisms\n * > to the value 'pre-wrap'. Default HTML whitespace handling is not well\n * > suited to WYSIWYG editing, and line wrapping will not work correctly in\n * > some corner cases if 'white-space' is left at its default value.\n *\n * https://html.spec.whatwg.org/multipage/interaction.html#best-practices-for-in-page-editors\n *\n * @type {string}\n */\nconst whiteSpace = 'pre-wrap';\n\n/**\n * A minimum width of 1px will prevent the rich text container from collapsing\n * to 0 width and hiding the caret. This is useful for inline containers.\n */\nconst minWidth = '1px';\nfunction useDefaultStyle() {\n  return (0, _element.useCallback)(element => {\n    if (!element) {\n      return;\n    }\n    element.style.whiteSpace = whiteSpace;\n    element.style.minWidth = minWidth;\n  }, []);\n}\n//# sourceMappingURL=use-default-style.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concat = concat;\nexports.mergePair = mergePair;\nvar _normaliseFormats = require(\"./normalise-formats\");\nvar _create = require(\"./create\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Concats a pair of rich text values. Not that this mutates `a` and does NOT\n * normalise formats!\n *\n * @param {Object} a Value to mutate.\n * @param {Object} b Value to add read from.\n *\n * @return {Object} `a`, mutated.\n */\nfunction mergePair(a, b) {\n  a.formats = a.formats.concat(b.formats);\n  a.replacements = a.replacements.concat(b.replacements);\n  a.text += b.text;\n  return a;\n}\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...RichTextValue} values Objects to combine.\n *\n * @return {RichTextValue} A new value combining all given records.\n */\nfunction concat(...values) {\n  return (0, _normaliseFormats.normaliseFormats)(values.reduce(mergePair, (0, _create.create)()));\n}\n//# sourceMappingURL=concat.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createElement = createElement;\n/**\n * Parse the given HTML into a body element.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createElement`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nfunction createElement({\n  implementation\n}, html) {\n  // Because `createHTMLDocument` is an expensive operation, and with this\n  // function being internal to `rich-text` (full control in avoiding a risk\n  // of asynchronous operations on the shared reference), a single document\n  // is reused and reset for each call to the function.\n  if (!createElement.body) {\n    createElement.body = implementation.createHTMLDocument('').body;\n  }\n  createElement.body.innerHTML = html;\n  return createElement.body;\n}\n//# sourceMappingURL=create-element.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RichTextData = void 0;\nexports.create = create;\nexports.removeReservedCharacters = removeReservedCharacters;\nvar _data = require(\"@wordpress/data\");\nvar _store = require(\"./store\");\nvar _createElement = require(\"./create-element\");\nvar _concat = require(\"./concat\");\nvar _specialCharacters = require(\"./special-characters\");\nvar _toHtmlString = require(\"./to-html-string\");\nvar _getTextContent = require(\"./get-text-content\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\nfunction createEmptyValue() {\n  return {\n    formats: [],\n    replacements: [],\n    text: ''\n  };\n}\nfunction toFormat({\n  tagName,\n  attributes\n}) {\n  let formatType;\n  if (attributes && attributes.class) {\n    formatType = (0, _data.select)(_store.store).getFormatTypeForClassName(attributes.class);\n    if (formatType) {\n      // Preserve any additional classes.\n      attributes.class = ` ${attributes.class} `.replace(` ${formatType.className} `, ' ').trim();\n      if (!attributes.class) {\n        delete attributes.class;\n      }\n    }\n  }\n  if (!formatType) {\n    formatType = (0, _data.select)(_store.store).getFormatTypeForBareElement(tagName);\n  }\n  if (!formatType) {\n    return attributes ? {\n      type: tagName,\n      attributes\n    } : {\n      type: tagName\n    };\n  }\n  if (formatType.__experimentalCreatePrepareEditableTree && !formatType.__experimentalCreateOnChangeEditableValue) {\n    return null;\n  }\n  if (!attributes) {\n    return {\n      formatType,\n      type: formatType.name,\n      tagName\n    };\n  }\n  const registeredAttributes = {};\n  const unregisteredAttributes = {};\n  const _attributes = {\n    ...attributes\n  };\n  for (const key in formatType.attributes) {\n    const name = formatType.attributes[key];\n    registeredAttributes[key] = _attributes[name];\n\n    // delete the attribute and what's left is considered\n    // to be unregistered.\n    delete _attributes[name];\n    if (typeof registeredAttributes[key] === 'undefined') {\n      delete registeredAttributes[key];\n    }\n  }\n  for (const name in _attributes) {\n    unregisteredAttributes[name] = attributes[name];\n  }\n  if (formatType.contentEditable === false) {\n    delete unregisteredAttributes.contenteditable;\n  }\n  return {\n    formatType,\n    type: formatType.name,\n    tagName,\n    attributes: registeredAttributes,\n    unregisteredAttributes\n  };\n}\n\n/**\n * The RichTextData class is used to instantiate a wrapper around rich text\n * values, with methods that can be used to transform or manipulate the data.\n *\n * - Create an empty instance: `new RichTextData()`.\n * - Create one from an HTML string: `RichTextData.fromHTMLString(\n *   '<em>hello</em>' )`.\n * - Create one from a wrapper HTMLElement: `RichTextData.fromHTMLElement(\n *   document.querySelector( 'p' ) )`.\n * - Create one from plain text: `RichTextData.fromPlainText( '1\\n2' )`.\n * - Create one from a rich text value: `new RichTextData( { text: '...',\n *   formats: [ ... ] } )`.\n *\n * @todo Add methods to manipulate the data, such as applyFormat, slice etc.\n */\nclass RichTextData {\n  #value;\n  static empty() {\n    return new RichTextData();\n  }\n  static fromPlainText(text) {\n    return new RichTextData(create({\n      text\n    }));\n  }\n  static fromHTMLString(html) {\n    return new RichTextData(create({\n      html\n    }));\n  }\n  /**\n   * Create a RichTextData instance from an HTML element.\n   *\n   * @param {HTMLElement}                    htmlElement The HTML element to create the instance from.\n   * @param {{preserveWhiteSpace?: boolean}} options     Options.\n   * @return {RichTextData} The RichTextData instance.\n   */\n  static fromHTMLElement(htmlElement, options = {}) {\n    const {\n      preserveWhiteSpace = false\n    } = options;\n    const element = preserveWhiteSpace ? htmlElement : collapseWhiteSpace(htmlElement);\n    const richTextData = new RichTextData(create({\n      element\n    }));\n    Object.defineProperty(richTextData, 'originalHTML', {\n      value: htmlElement.innerHTML\n    });\n    return richTextData;\n  }\n  constructor(init = createEmptyValue()) {\n    this.#value = init;\n  }\n  toPlainText() {\n    return (0, _getTextContent.getTextContent)(this.#value);\n  }\n  // We could expose `toHTMLElement` at some point as well, but we'd only use\n  // it internally.\n  /**\n   * Convert the rich text value to an HTML string.\n   *\n   * @param {{preserveWhiteSpace?: boolean}} options Options.\n   * @return {string} The HTML string.\n   */\n  toHTMLString({\n    preserveWhiteSpace\n  } = {}) {\n    return this.originalHTML || (0, _toHtmlString.toHTMLString)({\n      value: this.#value,\n      preserveWhiteSpace\n    });\n  }\n  valueOf() {\n    return this.toHTMLString();\n  }\n  toString() {\n    return this.toHTMLString();\n  }\n  toJSON() {\n    return this.toHTMLString();\n  }\n  get length() {\n    return this.text.length;\n  }\n  get formats() {\n    return this.#value.formats;\n  }\n  get replacements() {\n    return this.#value.replacements;\n  }\n  get text() {\n    return this.#value.text;\n  }\n}\nexports.RichTextData = RichTextData;\nfor (const name of Object.getOwnPropertyNames(String.prototype)) {\n  if (RichTextData.prototype.hasOwnProperty(name)) {\n    continue;\n  }\n  Object.defineProperty(RichTextData.prototype, name, {\n    value(...args) {\n      // Should we convert back to RichTextData?\n      return this.toHTMLString()[name](...args);\n    }\n  });\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. The optional\n * functions can be used to filter out content.\n *\n * A value will have the following shape, which you are strongly encouraged not\n * to modify without the use of helper functions:\n *\n * ```js\n * {\n *   text: string,\n *   formats: Array,\n *   replacements: Array,\n *   ?start: number,\n *   ?end: number,\n * }\n * ```\n *\n * As you can see, text and formatting are separated. `text` holds the text,\n * including any replacement characters for objects and lines. `formats`,\n * `objects` and `lines` are all sparse arrays of the same length as `text`. It\n * holds information about the formatting at the relevant text indices. Finally\n * `start` and `end` state which text indices are selected. They are only\n * provided if a `Range` was given.\n *\n * @param {Object}  [$1]                          Optional named arguments.\n * @param {Element} [$1.element]                  Element to create value from.\n * @param {string}  [$1.text]                     Text to create value from.\n * @param {string}  [$1.html]                     HTML to create value from.\n * @param {Range}   [$1.range]                    Range to create value from.\n * @param {boolean} [$1.__unstableIsEditableTree]\n * @return {RichTextValue} A rich text value.\n */\nfunction create({\n  element,\n  text,\n  html,\n  range,\n  __unstableIsEditableTree: isEditableTree\n} = {}) {\n  if (html instanceof RichTextData) {\n    return {\n      text: html.text,\n      formats: html.formats,\n      replacements: html.replacements\n    };\n  }\n  if (typeof text === 'string' && text.length > 0) {\n    return {\n      formats: Array(text.length),\n      replacements: Array(text.length),\n      text\n    };\n  }\n  if (typeof html === 'string' && html.length > 0) {\n    // It does not matter which document this is, we're just using it to\n    // parse.\n    element = (0, _createElement.createElement)(document, html);\n  }\n  if (typeof element !== 'object') {\n    return createEmptyValue();\n  }\n  return createFromElement({\n    element,\n    range,\n    isEditableTree\n  });\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection(accumulator, node, range, value) {\n  if (!range) {\n    return;\n  }\n  const {\n    parentNode\n  } = node;\n  const {\n    startContainer,\n    startOffset,\n    endContainer,\n    endOffset\n  } = range;\n  const currentLength = accumulator.text.length;\n\n  // Selection can be extracted from value.\n  if (value.start !== undefined) {\n    accumulator.start = currentLength + value.start;\n    // Range indicates that the current node has selection.\n  } else if (node === startContainer && node.nodeType === node.TEXT_NODE) {\n    accumulator.start = currentLength + startOffset;\n    // Range indicates that the current node is selected.\n  } else if (parentNode === startContainer && node === startContainer.childNodes[startOffset]) {\n    accumulator.start = currentLength;\n    // Range indicates that the selection is after the current node.\n  } else if (parentNode === startContainer && node === startContainer.childNodes[startOffset - 1]) {\n    accumulator.start = currentLength + value.text.length;\n    // Fallback if no child inside handled the selection.\n  } else if (node === startContainer) {\n    accumulator.start = currentLength;\n  }\n\n  // Selection can be extracted from value.\n  if (value.end !== undefined) {\n    accumulator.end = currentLength + value.end;\n    // Range indicates that the current node has selection.\n  } else if (node === endContainer && node.nodeType === node.TEXT_NODE) {\n    accumulator.end = currentLength + endOffset;\n    // Range indicates that the current node is selected.\n  } else if (parentNode === endContainer && node === endContainer.childNodes[endOffset - 1]) {\n    accumulator.end = currentLength + value.text.length;\n    // Range indicates that the selection is before the current node.\n  } else if (parentNode === endContainer && node === endContainer.childNodes[endOffset]) {\n    accumulator.end = currentLength;\n    // Fallback if no child inside handled the selection.\n  } else if (node === endContainer) {\n    accumulator.end = currentLength + endOffset;\n  }\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {Object|void} Object containing range properties.\n */\nfunction filterRange(node, range, filter) {\n  if (!range) {\n    return;\n  }\n  const {\n    startContainer,\n    endContainer\n  } = range;\n  let {\n    startOffset,\n    endOffset\n  } = range;\n  if (node === startContainer) {\n    startOffset = filter(node.nodeValue.slice(0, startOffset)).length;\n  }\n  if (node === endContainer) {\n    endOffset = filter(node.nodeValue.slice(0, endOffset)).length;\n  }\n  return {\n    startContainer,\n    startOffset,\n    endContainer,\n    endOffset\n  };\n}\n\n/**\n * Collapse any whitespace used for HTML formatting to one space character,\n * because it will also be displayed as such by the browser.\n *\n * We need to strip it from the content because we use white-space: pre-wrap for\n * displaying editable rich text. Without using white-space: pre-wrap, the\n * browser will litter the content with non breaking spaces, among other issues.\n * See packages/rich-text/src/component/use-default-style.js.\n *\n * @see\n * https://developer.mozilla.org/en-US/docs/Web/CSS/white-space-collapse#collapsing_of_white_space\n *\n * @param {HTMLElement} element\n * @param {boolean}     isRoot\n *\n * @return {HTMLElement} New element with collapsed whitespace.\n */\nfunction collapseWhiteSpace(element, isRoot = true) {\n  const clone = element.cloneNode(true);\n  clone.normalize();\n  Array.from(clone.childNodes).forEach((node, i, nodes) => {\n    if (node.nodeType === node.TEXT_NODE) {\n      let newNodeValue = node.nodeValue;\n      if (/[\\n\\t\\r\\f]/.test(newNodeValue)) {\n        newNodeValue = newNodeValue.replace(/[\\n\\t\\r\\f]+/g, ' ');\n      }\n      if (newNodeValue.indexOf('  ') !== -1) {\n        newNodeValue = newNodeValue.replace(/ {2,}/g, ' ');\n      }\n      if (i === 0 && newNodeValue.startsWith(' ')) {\n        newNodeValue = newNodeValue.slice(1);\n      } else if (isRoot && i === nodes.length - 1 && newNodeValue.endsWith(' ')) {\n        newNodeValue = newNodeValue.slice(0, -1);\n      }\n      node.nodeValue = newNodeValue;\n    } else if (node.nodeType === node.ELEMENT_NODE) {\n      collapseWhiteSpace(node, false);\n    }\n  });\n  return clone;\n}\n\n/**\n * We need to normalise line breaks to `\\n` so they are consistent across\n * platforms and serialised properly. Not removing \\r would cause it to\n * linger and result in double line breaks when whitespace is preserved.\n */\nconst CARRIAGE_RETURN = '\\r';\n\n/**\n * Removes reserved characters used by rich-text (zero width non breaking spaces\n * added by `toTree` and object replacement characters).\n *\n * @param {string} string\n */\nfunction removeReservedCharacters(string) {\n  // with the global flag, note that we should create a new regex each time OR\n  // reset lastIndex state.\n  return string.replace(new RegExp(`[${_specialCharacters.ZWNBSP}${_specialCharacters.OBJECT_REPLACEMENT_CHARACTER}${CARRIAGE_RETURN}]`, 'gu'), '');\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}  $1                  Named arguments.\n * @param {Element} [$1.element]        Element to create value from.\n * @param {Range}   [$1.range]          Range to create value from.\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromElement({\n  element,\n  range,\n  isEditableTree\n}) {\n  const accumulator = createEmptyValue();\n  if (!element) {\n    return accumulator;\n  }\n  if (!element.hasChildNodes()) {\n    accumulateSelection(accumulator, element, range, createEmptyValue());\n    return accumulator;\n  }\n  const length = element.childNodes.length;\n\n  // Optimise for speed.\n  for (let index = 0; index < length; index++) {\n    const node = element.childNodes[index];\n    const tagName = node.nodeName.toLowerCase();\n    if (node.nodeType === node.TEXT_NODE) {\n      const text = removeReservedCharacters(node.nodeValue);\n      range = filterRange(node, range, removeReservedCharacters);\n      accumulateSelection(accumulator, node, range, {\n        text\n      });\n      // Create a sparse array of the same length as `text`, in which\n      // formats can be added.\n      accumulator.formats.length += text.length;\n      accumulator.replacements.length += text.length;\n      accumulator.text += text;\n      continue;\n    }\n    if (node.nodeType === node.COMMENT_NODE || node.nodeType === node.ELEMENT_NODE && node.tagName === 'SPAN' && node.hasAttribute('data-rich-text-comment')) {\n      const value = {\n        formats: [,],\n        replacements: [{\n          type: '#comment',\n          attributes: {\n            'data-rich-text-comment': node.nodeType === node.COMMENT_NODE ? node.nodeValue : node.getAttribute('data-rich-text-comment')\n          }\n        }],\n        text: _specialCharacters.OBJECT_REPLACEMENT_CHARACTER\n      };\n      accumulateSelection(accumulator, node, range, value);\n      (0, _concat.mergePair)(accumulator, value);\n      continue;\n    }\n    if (node.nodeType !== node.ELEMENT_NODE) {\n      continue;\n    }\n    if (isEditableTree &&\n    // Ignore any line breaks that are not inserted by us.\n    tagName === 'br' && !node.getAttribute('data-rich-text-line-break')) {\n      accumulateSelection(accumulator, node, range, createEmptyValue());\n      continue;\n    }\n    if (tagName === 'script') {\n      const value = {\n        formats: [,],\n        replacements: [{\n          type: tagName,\n          attributes: {\n            'data-rich-text-script': node.getAttribute('data-rich-text-script') || encodeURIComponent(node.innerHTML)\n          }\n        }],\n        text: _specialCharacters.OBJECT_REPLACEMENT_CHARACTER\n      };\n      accumulateSelection(accumulator, node, range, value);\n      (0, _concat.mergePair)(accumulator, value);\n      continue;\n    }\n    if (tagName === 'br') {\n      accumulateSelection(accumulator, node, range, createEmptyValue());\n      (0, _concat.mergePair)(accumulator, create({\n        text: '\\n'\n      }));\n      continue;\n    }\n    const format = toFormat({\n      tagName,\n      attributes: getAttributes({\n        element: node\n      })\n    });\n\n    // When a format type is declared as not editable, replace it with an\n    // object replacement character and preserve the inner HTML.\n    if (format?.formatType?.contentEditable === false) {\n      delete format.formatType;\n      accumulateSelection(accumulator, node, range, createEmptyValue());\n      (0, _concat.mergePair)(accumulator, {\n        formats: [,],\n        replacements: [{\n          ...format,\n          innerHTML: node.innerHTML\n        }],\n        text: _specialCharacters.OBJECT_REPLACEMENT_CHARACTER\n      });\n      continue;\n    }\n    if (format) {\n      delete format.formatType;\n    }\n    const value = createFromElement({\n      element: node,\n      range,\n      isEditableTree\n    });\n    accumulateSelection(accumulator, node, range, value);\n\n    // Ignore any placeholders, but keep their content since the browser\n    // might insert text inside them when the editable element is flex.\n    if (!format || node.getAttribute('data-rich-text-placeholder')) {\n      (0, _concat.mergePair)(accumulator, value);\n    } else if (value.text.length === 0) {\n      if (format.attributes) {\n        (0, _concat.mergePair)(accumulator, {\n          formats: [,],\n          replacements: [format],\n          text: _specialCharacters.OBJECT_REPLACEMENT_CHARACTER\n        });\n      }\n    } else {\n      // Indices should share a reference to the same formats array.\n      // Only create a new reference if `formats` changes.\n      function mergeFormats(formats) {\n        if (mergeFormats.formats === formats) {\n          return mergeFormats.newFormats;\n        }\n        const newFormats = formats ? [format, ...formats] : [format];\n        mergeFormats.formats = formats;\n        mergeFormats.newFormats = newFormats;\n        return newFormats;\n      }\n\n      // Since the formats parameter can be `undefined`, preset\n      // `mergeFormats` with a new reference.\n      mergeFormats.newFormats = [format];\n      (0, _concat.mergePair)(accumulator, {\n        ...value,\n        formats: Array.from(value.formats, mergeFormats)\n      });\n    }\n  }\n  return accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}  $1         Named arguments.\n * @param {Element} $1.element Element to get attributes from.\n *\n * @return {Object|void} Attribute object or `undefined` if the element has no\n *                       attributes.\n */\nfunction getAttributes({\n  element\n}) {\n  if (!element.hasAttributes()) {\n    return;\n  }\n  const length = element.attributes.length;\n  let accumulator;\n\n  // Optimise for speed.\n  for (let i = 0; i < length; i++) {\n    const {\n      name,\n      value\n    } = element.attributes[i];\n    if (name.indexOf('data-rich-text-') === 0) {\n      continue;\n    }\n    const safeName = /^on/i.test(name) ? 'data-disable-rich-text-' + name : name;\n    accumulator = accumulator || {};\n    accumulator[safeName] = value;\n  }\n  return accumulator;\n}\n//# sourceMappingURL=create.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getActiveFormat = getActiveFormat;\nvar _getActiveFormats = require(\"./get-active-formats\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {RichTextValue} value      Value to inspect.\n * @param {string}        formatType Format type to look for.\n *\n * @return {RichTextFormat|undefined} Active format object of the specified\n *                                    type, or undefined.\n */\nfunction getActiveFormat(value, formatType) {\n  return (0, _getActiveFormats.getActiveFormats)(value).find(({\n    type\n  }) => type === formatType);\n}\n//# sourceMappingURL=get-active-format.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getActiveFormats = getActiveFormats;\nvar _isFormatEqual = require(\"./is-format-equal\");\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormatList} RichTextFormatList */\n\n/**\n * Internal dependencies\n */\n\n/**\n * Gets the all format objects at the start of the selection.\n *\n * @param {RichTextValue} value                Value to inspect.\n * @param {Array}         EMPTY_ACTIVE_FORMATS Array to return if there are no\n *                                             active formats.\n *\n * @return {RichTextFormatList} Active format objects.\n */\nfunction getActiveFormats(value, EMPTY_ACTIVE_FORMATS = []) {\n  const {\n    formats,\n    start,\n    end,\n    activeFormats\n  } = value;\n  if (start === undefined) {\n    return EMPTY_ACTIVE_FORMATS;\n  }\n  if (start === end) {\n    // For a collapsed caret, it is possible to override the active formats.\n    if (activeFormats) {\n      return activeFormats;\n    }\n    const formatsBefore = formats[start - 1] || EMPTY_ACTIVE_FORMATS;\n    const formatsAfter = formats[start] || EMPTY_ACTIVE_FORMATS;\n\n    // By default, select the lowest amount of formats possible (which means\n    // the caret is positioned outside the format boundary). The user can\n    // then use arrow keys to define `activeFormats`.\n    if (formatsBefore.length < formatsAfter.length) {\n      return formatsBefore;\n    }\n    return formatsAfter;\n  }\n\n  // If there's no formats at the start index, there are not active formats.\n  if (!formats[start]) {\n    return EMPTY_ACTIVE_FORMATS;\n  }\n  const selectedFormats = formats.slice(start, end);\n\n  // Clone the formats so we're not mutating the live value.\n  const _activeFormats = [...selectedFormats[0]];\n  let i = selectedFormats.length;\n\n  // For performance reasons, start from the end where it's much quicker to\n  // realise that there are no active formats.\n  while (i--) {\n    const formatsAtIndex = selectedFormats[i];\n\n    // If we run into any index without formats, we're sure that there's no\n    // active formats.\n    if (!formatsAtIndex) {\n      return EMPTY_ACTIVE_FORMATS;\n    }\n    let ii = _activeFormats.length;\n\n    // Loop over the active formats and remove any that are not present at\n    // the current index.\n    while (ii--) {\n      const format = _activeFormats[ii];\n      if (!formatsAtIndex.find(_format => (0, _isFormatEqual.isFormatEqual)(format, _format))) {\n        _activeFormats.splice(ii, 1);\n      }\n    }\n\n    // If there are no active formats, we can stop.\n    if (_activeFormats.length === 0) {\n      return EMPTY_ACTIVE_FORMATS;\n    }\n  }\n  return _activeFormats || EMPTY_ACTIVE_FORMATS;\n}\n//# sourceMappingURL=get-active-formats.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getActiveObject = getActiveObject;\nvar _specialCharacters = require(\"./special-characters\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the active object, if there is any.\n *\n * @param {RichTextValue} value Value to inspect.\n *\n * @return {RichTextFormat|void} Active object, or undefined.\n */\nfunction getActiveObject({\n  start,\n  end,\n  replacements,\n  text\n}) {\n  if (start + 1 !== end || text[start] !== _specialCharacters.OBJECT_REPLACEMENT_CHARACTER) {\n    return;\n  }\n  return replacements[start];\n}\n//# sourceMappingURL=get-active-object.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFormatType = getFormatType;\nvar _data = require(\"@wordpress/data\");\nvar _store = require(\"./store\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */\n\n/**\n * Returns a registered format type.\n *\n * @param {string} name Format name.\n *\n * @return {RichTextFormatType|undefined} Format type.\n */\nfunction getFormatType(name) {\n  return (0, _data.select)(_store.store).getFormatType(name);\n}\n//# sourceMappingURL=get-format-type.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getTextContent = getTextContent;\nvar _specialCharacters = require(\"./special-characters\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {string} The text content.\n */\nfunction getTextContent({\n  text\n}) {\n  return text.replace(_specialCharacters.OBJECT_REPLACEMENT_CHARACTER, '');\n}\n//# sourceMappingURL=get-text-content.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertObject = insertObject;\nvar _insert = require(\"./insert\");\nvar _specialCharacters = require(\"./special-characters\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Insert a format as an object into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue}  value          Value to modify.\n * @param {RichTextFormat} formatToInsert Format to insert as object.\n * @param {number}         [startIndex]   Start index.\n * @param {number}         [endIndex]     End index.\n *\n * @return {RichTextValue} A new value with the object inserted.\n */\nfunction insertObject(value, formatToInsert, startIndex, endIndex) {\n  const valueToInsert = {\n    formats: [,],\n    replacements: [formatToInsert],\n    text: _specialCharacters.OBJECT_REPLACEMENT_CHARACTER\n  };\n  return (0, _insert.insert)(value, valueToInsert, startIndex, endIndex);\n}\n//# sourceMappingURL=insert-object.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insert = insert;\nvar _create = require(\"./create\");\nvar _normaliseFormats = require(\"./normalise-formats\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {RichTextValue}        value         Value to modify.\n * @param {RichTextValue|string} valueToInsert Value to insert.\n * @param {number}               [startIndex]  Start index.\n * @param {number}               [endIndex]    End index.\n *\n * @return {RichTextValue} A new value with the value inserted.\n */\nfunction insert(value, valueToInsert, startIndex = value.start, endIndex = value.end) {\n  const {\n    formats,\n    replacements,\n    text\n  } = value;\n  if (typeof valueToInsert === 'string') {\n    valueToInsert = (0, _create.create)({\n      text: valueToInsert\n    });\n  }\n  const index = startIndex + valueToInsert.text.length;\n  return (0, _normaliseFormats.normaliseFormats)({\n    formats: formats.slice(0, startIndex).concat(valueToInsert.formats, formats.slice(endIndex)),\n    replacements: replacements.slice(0, startIndex).concat(valueToInsert.replacements, replacements.slice(endIndex)),\n    text: text.slice(0, startIndex) + valueToInsert.text + text.slice(endIndex),\n    start: index,\n    end: index\n  });\n}\n//# sourceMappingURL=insert.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isCollapsed = isCollapsed;\n/**\n * Internal dependencies\n */\n\n/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param props       The rich text value to check.\n * @param props.start\n * @param props.end\n * @return True if the selection is collapsed, false if not, undefined if there is no selection.\n */\nfunction isCollapsed({\n  start,\n  end\n}) {\n  if (start === undefined || end === undefined) {\n    return;\n  }\n  return start === end;\n}\n//# sourceMappingURL=is-collapsed.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isEmpty = isEmpty;\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nfunction isEmpty({\n  text\n}) {\n  return text.length === 0;\n}\n//# sourceMappingURL=is-empty.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isFormatEqual = isFormatEqual;\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Optimised equality check for format objects.\n *\n * @param {?RichTextFormat} format1 Format to compare.\n * @param {?RichTextFormat} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nfunction isFormatEqual(format1, format2) {\n  // Both not defined.\n  if (format1 === format2) {\n    return true;\n  }\n\n  // Either not defined.\n  if (!format1 || !format2) {\n    return false;\n  }\n  if (format1.type !== format2.type) {\n    return false;\n  }\n  const attributes1 = format1.attributes;\n  const attributes2 = format2.attributes;\n\n  // Both not defined.\n  if (attributes1 === attributes2) {\n    return true;\n  }\n\n  // Either not defined.\n  if (!attributes1 || !attributes2) {\n    return false;\n  }\n  const keys1 = Object.keys(attributes1);\n  const keys2 = Object.keys(attributes2);\n  if (keys1.length !== keys2.length) {\n    return false;\n  }\n  const length = keys1.length;\n\n  // Optimise for speed.\n  for (let i = 0; i < length; i++) {\n    const name = keys1[i];\n    if (attributes1[name] !== attributes2[name]) {\n      return false;\n    }\n  }\n  return true;\n}\n//# sourceMappingURL=is-format-equal.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isRangeEqual = isRangeEqual;\n/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range|null} a First range object to test.\n * @param {Range|null} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nfunction isRangeEqual(a, b) {\n  return a === b || a && b && a.startContainer === b.startContainer && a.startOffset === b.startOffset && a.endContainer === b.endContainer && a.endOffset === b.endOffset;\n}\n//# sourceMappingURL=is-range-equal.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.join = join;\nvar _create = require(\"./create\");\nvar _normaliseFormats = require(\"./normalise-formats\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array<RichTextValue>} values      An array of values to join.\n * @param {string|RichTextValue} [separator] Separator string or value.\n *\n * @return {RichTextValue} A new combined value.\n */\nfunction join(values, separator = '') {\n  if (typeof separator === 'string') {\n    separator = (0, _create.create)({\n      text: separator\n    });\n  }\n  return (0, _normaliseFormats.normaliseFormats)(values.reduce((accumlator, {\n    formats,\n    replacements,\n    text\n  }) => ({\n    formats: accumlator.formats.concat(separator.formats, formats),\n    replacements: accumlator.replacements.concat(separator.replacements, replacements),\n    text: accumlator.text + separator.text + text\n  })));\n}\n//# sourceMappingURL=join.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.normaliseFormats = normaliseFormats;\nvar _isFormatEqual = require(\"./is-format-equal\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Normalises formats: ensures subsequent adjacent equal formats have the same\n * reference.\n *\n * @param {RichTextValue} value Value to normalise formats of.\n *\n * @return {RichTextValue} New value with normalised formats.\n */\nfunction normaliseFormats(value) {\n  const newFormats = value.formats.slice();\n  newFormats.forEach((formatsAtIndex, index) => {\n    const formatsAtPreviousIndex = newFormats[index - 1];\n    if (formatsAtPreviousIndex) {\n      const newFormatsAtIndex = formatsAtIndex.slice();\n      newFormatsAtIndex.forEach((format, formatIndex) => {\n        const previousFormat = formatsAtPreviousIndex[formatIndex];\n        if ((0, _isFormatEqual.isFormatEqual)(format, previousFormat)) {\n          newFormatsAtIndex[formatIndex] = previousFormat;\n        }\n      });\n      newFormats[index] = newFormatsAtIndex;\n    }\n  });\n  return {\n    ...value,\n    formats: newFormats\n  };\n}\n//# sourceMappingURL=normalise-formats.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.registerFormatType = registerFormatType;\nvar _data = require(\"@wordpress/data\");\nvar _store = require(\"./store\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\n/**\n * @typedef {Object} WPFormat\n *\n * @property {string}        name        A string identifying the format. Must be\n *                                       unique across all registered formats.\n * @property {string}        tagName     The HTML tag this format will wrap the\n *                                       selection with.\n * @property {boolean}       interactive Whether format makes content interactive or not.\n * @property {string | null} [className] A class to match the format.\n * @property {string}        title       Name of the format.\n * @property {Function}      edit        Should return a component for the user to\n *                                       interact with the new registered format.\n */\n\n/**\n * Registers a new format provided a unique name and an object defining its\n * behavior.\n *\n * @param {string}   name     Format name.\n * @param {WPFormat} settings Format settings.\n *\n * @return {WPFormat|undefined} The format, if it has been successfully\n *                              registered; otherwise `undefined`.\n */\nfunction registerFormatType(name, settings) {\n  settings = {\n    name,\n    ...settings\n  };\n  if (typeof settings.name !== 'string') {\n    window.console.error('Format names must be strings.');\n    return;\n  }\n  if (!/^[a-z][a-z0-9-]*\\/[a-z][a-z0-9-]*$/.test(settings.name)) {\n    window.console.error('Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format');\n    return;\n  }\n  if ((0, _data.select)(_store.store).getFormatType(settings.name)) {\n    window.console.error('Format \"' + settings.name + '\" is already registered.');\n    return;\n  }\n  if (typeof settings.tagName !== 'string' || settings.tagName === '') {\n    window.console.error('Format tag names must be a string.');\n    return;\n  }\n  if ((typeof settings.className !== 'string' || settings.className === '') && settings.className !== null) {\n    window.console.error('Format class names must be a string, or null to handle bare elements.');\n    return;\n  }\n  if (!/^[_a-zA-Z]+[a-zA-Z0-9_-]*$/.test(settings.className)) {\n    window.console.error('A class name must begin with a letter, followed by any number of hyphens, underscores, letters, or numbers.');\n    return;\n  }\n  if (settings.className === null) {\n    const formatTypeForBareElement = (0, _data.select)(_store.store).getFormatTypeForBareElement(settings.tagName);\n    if (formatTypeForBareElement && formatTypeForBareElement.name !== 'core/unknown') {\n      window.console.error(`Format \"${formatTypeForBareElement.name}\" is already registered to handle bare tag name \"${settings.tagName}\".`);\n      return;\n    }\n  } else {\n    const formatTypeForClassName = (0, _data.select)(_store.store).getFormatTypeForClassName(settings.className);\n    if (formatTypeForClassName) {\n      window.console.error(`Format \"${formatTypeForClassName.name}\" is already registered to handle class name \"${settings.className}\".`);\n      return;\n    }\n  }\n  if (!('title' in settings) || settings.title === '') {\n    window.console.error('The format \"' + settings.name + '\" must have a title.');\n    return;\n  }\n  if ('keywords' in settings && settings.keywords.length > 3) {\n    window.console.error('The format \"' + settings.name + '\" can have a maximum of 3 keywords.');\n    return;\n  }\n  if (typeof settings.title !== 'string') {\n    window.console.error('Format titles must be strings.');\n    return;\n  }\n  (0, _data.dispatch)(_store.store).addFormatTypes(settings);\n  return settings;\n}\n//# sourceMappingURL=register-format-type.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeFormat = removeFormat;\nvar _normaliseFormats = require(\"./normalise-formats\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {string}        formatType   Format type to remove.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nfunction removeFormat(value, formatType, startIndex = value.start, endIndex = value.end) {\n  const {\n    formats,\n    activeFormats\n  } = value;\n  const newFormats = formats.slice();\n\n  // If the selection is collapsed, expand start and end to the edges of the\n  // format.\n  if (startIndex === endIndex) {\n    const format = newFormats[startIndex]?.find(({\n      type\n    }) => type === formatType);\n    if (format) {\n      while (newFormats[startIndex]?.find(newFormat => newFormat === format)) {\n        filterFormats(newFormats, startIndex, formatType);\n        startIndex--;\n      }\n      endIndex++;\n      while (newFormats[endIndex]?.find(newFormat => newFormat === format)) {\n        filterFormats(newFormats, endIndex, formatType);\n        endIndex++;\n      }\n    }\n  } else {\n    for (let i = startIndex; i < endIndex; i++) {\n      if (newFormats[i]) {\n        filterFormats(newFormats, i, formatType);\n      }\n    }\n  }\n  return (0, _normaliseFormats.normaliseFormats)({\n    ...value,\n    formats: newFormats,\n    activeFormats: activeFormats?.filter(({\n      type\n    }) => type !== formatType) || []\n  });\n}\nfunction filterFormats(formats, index, formatType) {\n  const newFormats = formats[index].filter(({\n    type\n  }) => type !== formatType);\n  if (newFormats.length) {\n    formats[index] = newFormats;\n  } else {\n    delete formats[index];\n  }\n}\n//# sourceMappingURL=remove-format.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.remove = remove;\nvar _insert = require(\"./insert\");\nvar _create = require(\"./create\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the content removed.\n */\nfunction remove(value, startIndex, endIndex) {\n  return (0, _insert.insert)(value, (0, _create.create)(), startIndex, endIndex);\n}\n//# sourceMappingURL=remove.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replace = replace;\nvar _normaliseFormats = require(\"./normalise-formats\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {RichTextValue}   value       The value to modify.\n * @param {RegExp|string}   pattern     A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {RichTextValue} A new value with replacements applied.\n */\nfunction replace({\n  formats,\n  replacements,\n  text,\n  start,\n  end\n}, pattern, replacement) {\n  text = text.replace(pattern, (match, ...rest) => {\n    const offset = rest[rest.length - 2];\n    let newText = replacement;\n    let newFormats;\n    let newReplacements;\n    if (typeof newText === 'function') {\n      newText = replacement(match, ...rest);\n    }\n    if (typeof newText === 'object') {\n      newFormats = newText.formats;\n      newReplacements = newText.replacements;\n      newText = newText.text;\n    } else {\n      newFormats = Array(newText.length);\n      newReplacements = Array(newText.length);\n      if (formats[offset]) {\n        newFormats = newFormats.fill(formats[offset]);\n      }\n    }\n    formats = formats.slice(0, offset).concat(newFormats, formats.slice(offset + match.length));\n    replacements = replacements.slice(0, offset).concat(newReplacements, replacements.slice(offset + match.length));\n    if (start) {\n      start = end = offset + newText.length;\n    }\n    return newText;\n  });\n  return (0, _normaliseFormats.normaliseFormats)({\n    formats,\n    replacements,\n    text,\n    start,\n    end\n  });\n}\n//# sourceMappingURL=replace.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.slice = slice;\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new extracted value.\n */\nfunction slice(value, startIndex = value.start, endIndex = value.end) {\n  const {\n    formats,\n    replacements,\n    text\n  } = value;\n  if (startIndex === undefined || endIndex === undefined) {\n    return {\n      ...value\n    };\n  }\n  return {\n    formats: formats.slice(startIndex, endIndex),\n    replacements: replacements.slice(startIndex, endIndex),\n    text: text.slice(startIndex, endIndex)\n  };\n}\n//# sourceMappingURL=slice.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ZWNBSP = exports.OBJECT_REPLACEMENT_CHARACTER = void 0;\n/**\n * Object replacement character, used as a placeholder for objects.\n */\nconst OBJECT_REPLACEMENT_CHARACTER = exports.OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\n\n/**\n * Zero width non-breaking space, used as padding in the editable DOM tree when\n * it is empty otherwise.\n */\nconst ZWNBSP = exports.ZWNBSP = '\\ufeff';\n//# sourceMappingURL=special-characters.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.split = split;\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>|undefined} An array of new values.\n */\nfunction split({\n  formats,\n  replacements,\n  text,\n  start,\n  end\n}, string) {\n  if (typeof string !== 'string') {\n    return splitAtSelection(...arguments);\n  }\n  let nextStart = 0;\n  return text.split(string).map(substring => {\n    const startIndex = nextStart;\n    const value = {\n      formats: formats.slice(startIndex, startIndex + substring.length),\n      replacements: replacements.slice(startIndex, startIndex + substring.length),\n      text: substring\n    };\n    nextStart += string.length + substring.length;\n    if (start !== undefined && end !== undefined) {\n      if (start >= startIndex && start < nextStart) {\n        value.start = start - startIndex;\n      } else if (start < startIndex && end > startIndex) {\n        value.start = 0;\n      }\n      if (end >= startIndex && end < nextStart) {\n        value.end = end - startIndex;\n      } else if (start < nextStart && end > nextStart) {\n        value.end = substring.length;\n      }\n    }\n    return value;\n  });\n}\nfunction splitAtSelection({\n  formats,\n  replacements,\n  text,\n  start,\n  end\n}, startIndex = start, endIndex = end) {\n  if (start === undefined || end === undefined) {\n    return;\n  }\n  const before = {\n    formats: formats.slice(0, startIndex),\n    replacements: replacements.slice(0, startIndex),\n    text: text.slice(0, startIndex)\n  };\n  const after = {\n    formats: formats.slice(endIndex),\n    replacements: replacements.slice(endIndex),\n    text: text.slice(endIndex),\n    start: 0,\n    end: 0\n  };\n  return [before, after];\n}\n//# sourceMappingURL=split.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addFormatTypes = addFormatTypes;\nexports.removeFormatTypes = removeFormatTypes;\n/**\n * Returns an action object used in signalling that format types have been\n * added.\n * Ignored from documentation as registerFormatType should be used instead from @wordpress/rich-text\n *\n * @ignore\n *\n * @param {Array|Object} formatTypes Format types received.\n *\n * @return {Object} Action object.\n */\nfunction addFormatTypes(formatTypes) {\n  return {\n    type: 'ADD_FORMAT_TYPES',\n    formatTypes: Array.isArray(formatTypes) ? formatTypes : [formatTypes]\n  };\n}\n\n/**\n * Returns an action object used to remove a registered format type.\n *\n * Ignored from documentation as unregisterFormatType should be used instead from @wordpress/rich-text\n *\n * @ignore\n *\n * @param {string|Array} names Format name.\n *\n * @return {Object} Action object.\n */\nfunction removeFormatTypes(names) {\n  return {\n    type: 'REMOVE_FORMAT_TYPES',\n    names: Array.isArray(names) ? names : [names]\n  };\n}\n//# sourceMappingURL=actions.js.map","\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.store = void 0;\nvar _data = require(\"@wordpress/data\");\nvar _reducer = _interopRequireDefault(require(\"./reducer\"));\nvar selectors = _interopRequireWildcard(require(\"./selectors\"));\nvar actions = _interopRequireWildcard(require(\"./actions\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\nconst STORE_NAME = 'core/rich-text';\n\n/**\n * Store definition for the rich-text namespace.\n *\n * @see https://github.com/WordPress/gutenberg/blob/HEAD/packages/data/README.md#createReduxStore\n *\n * @type {Object}\n */\nconst store = exports.store = (0, _data.createReduxStore)(STORE_NAME, {\n  reducer: _reducer.default,\n  selectors,\n  actions\n});\n(0, _data.register)(store);\n//# sourceMappingURL=index.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nexports.formatTypes = formatTypes;\nvar _data = require(\"@wordpress/data\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Reducer managing the format types\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Updated state.\n */\nfunction formatTypes(state = {}, action) {\n  switch (action.type) {\n    case 'ADD_FORMAT_TYPES':\n      return {\n        ...state,\n        // Key format types by their name.\n        ...action.formatTypes.reduce((newFormatTypes, type) => ({\n          ...newFormatTypes,\n          [type.name]: type\n        }), {})\n      };\n    case 'REMOVE_FORMAT_TYPES':\n      return Object.fromEntries(Object.entries(state).filter(([key]) => !action.names.includes(key)));\n  }\n  return state;\n}\nvar _default = exports.default = (0, _data.combineReducers)({\n  formatTypes\n});\n//# sourceMappingURL=reducer.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFormatType = getFormatType;\nexports.getFormatTypeForBareElement = getFormatTypeForBareElement;\nexports.getFormatTypeForClassName = getFormatTypeForClassName;\nexports.getFormatTypes = void 0;\nvar _data = require(\"@wordpress/data\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypes } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const availableFormats = getFormatTypes();\n *\n *    return availableFormats ? (\n *        <ul>\n *            { availableFormats?.map( ( format ) => (\n *                <li>{ format.name }</li>\n *           ) ) }\n *        </ul>\n *    ) : (\n *        __( 'No Formats available' )\n *    );\n * };\n * ```\n *\n * @return {Array} Format types.\n */\nconst getFormatTypes = exports.getFormatTypes = (0, _data.createSelector)(state => Object.values(state.formatTypes), state => [state.formatTypes]);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name  Format type name.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatType } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const boldFormat = getFormatType( 'core/bold' );\n *\n *    return boldFormat ? (\n *        <ul>\n *            { Object.entries( boldFormat )?.map( ( [ key, value ] ) => (\n *                <li>\n *                    { key } : { value }\n *                </li>\n *           ) ) }\n *       </ul>\n *    ) : (\n *        __( 'Not Found' )\n *    ;\n * };\n * ```\n *\n * @return {Object?} Format type.\n */\nfunction getFormatType(state, name) {\n  return state.formatTypes[name];\n}\n\n/**\n * Gets the format type, if any, that can handle a bare element (without a\n * data-format-type attribute), given the tag name of this element.\n *\n * @param {Object} state              Data state.\n * @param {string} bareElementTagName The tag name of the element to find a\n *                                    format type for.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypeForBareElement } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const format = getFormatTypeForBareElement( 'strong' );\n *\n *    return format && <p>{ sprintf( __( 'Format name: %s' ), format.name ) }</p>;\n * }\n * ```\n *\n * @return {?Object} Format type.\n */\nfunction getFormatTypeForBareElement(state, bareElementTagName) {\n  const formatTypes = getFormatTypes(state);\n  return formatTypes.find(({\n    className,\n    tagName\n  }) => {\n    return className === null && bareElementTagName === tagName;\n  }) || formatTypes.find(({\n    className,\n    tagName\n  }) => {\n    return className === null && '*' === tagName;\n  });\n}\n\n/**\n * Gets the format type, if any, that can handle an element, given its classes.\n *\n * @param {Object} state            Data state.\n * @param {string} elementClassName The classes of the element to find a format\n *                                  type for.\n *\n * @example\n * ```js\n * import { __, sprintf } from '@wordpress/i18n';\n * import { store as richTextStore } from '@wordpress/rich-text';\n * import { useSelect } from '@wordpress/data';\n *\n * const ExampleComponent = () => {\n *    const { getFormatTypeForClassName } = useSelect(\n *        ( select ) => select( richTextStore ),\n *        []\n *    );\n *\n *    const format = getFormatTypeForClassName( 'has-inline-color' );\n *\n *    return format && <p>{ sprintf( __( 'Format name: %s' ), format.name ) }</p>;\n * };\n * ```\n *\n * @return {?Object} Format type.\n */\nfunction getFormatTypeForClassName(state, elementClassName) {\n  return getFormatTypes(state).find(({\n    className\n  }) => {\n    if (className === null) {\n      return false;\n    }\n    return ` ${elementClassName} `.indexOf(` ${className} `) >= 0;\n  });\n}\n//# sourceMappingURL=selectors.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.apply = apply;\nexports.applySelection = applySelection;\nexports.applyValue = applyValue;\nexports.toDom = toDom;\nvar _toTree = require(\"./to-tree\");\nvar _createElement = require(\"./create-element\");\nvar _isRangeEqual = require(\"./is-range-equal\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode(node, rootNode, path) {\n  const parentNode = node.parentNode;\n  let i = 0;\n  while (node = node.previousSibling) {\n    i++;\n  }\n  path = [i, ...path];\n  if (parentNode !== rootNode) {\n    path = createPathToNode(parentNode, rootNode, path);\n  }\n  return path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath(node, path) {\n  path = [...path];\n  while (node && path.length > 1) {\n    node = node.childNodes[path.shift()];\n  }\n  return {\n    node,\n    offset: path[0]\n  };\n}\nfunction append(element, child) {\n  if (child.html !== undefined) {\n    return element.innerHTML += child.html;\n  }\n  if (typeof child === 'string') {\n    child = element.ownerDocument.createTextNode(child);\n  }\n  const {\n    type,\n    attributes\n  } = child;\n  if (type) {\n    if (type === '#comment') {\n      child = element.ownerDocument.createComment(attributes['data-rich-text-comment']);\n    } else {\n      child = element.ownerDocument.createElement(type);\n      for (const key in attributes) {\n        child.setAttribute(key, attributes[key]);\n      }\n    }\n  }\n  return element.appendChild(child);\n}\nfunction appendText(node, text) {\n  node.appendData(text);\n}\nfunction getLastChild({\n  lastChild\n}) {\n  return lastChild;\n}\nfunction getParent({\n  parentNode\n}) {\n  return parentNode;\n}\nfunction isText(node) {\n  return node.nodeType === node.TEXT_NODE;\n}\nfunction getText({\n  nodeValue\n}) {\n  return nodeValue;\n}\nfunction remove(node) {\n  return node.parentNode.removeChild(node);\n}\nfunction toDom({\n  value,\n  prepareEditableTree,\n  isEditableTree = true,\n  placeholder,\n  doc = document\n}) {\n  let startPath = [];\n  let endPath = [];\n  if (prepareEditableTree) {\n    value = {\n      ...value,\n      formats: prepareEditableTree(value)\n    };\n  }\n\n  /**\n   * Returns a new instance of a DOM tree upon which RichText operations can be\n   * applied.\n   *\n   * Note: The current implementation will return a shared reference, reset on\n   * each call to `createEmpty`. Therefore, you should not hold a reference to\n   * the value to operate upon asynchronously, as it may have unexpected results.\n   *\n   * @return {Object} RichText tree.\n   */\n  const createEmpty = () => (0, _createElement.createElement)(doc, '');\n  const tree = (0, _toTree.toTree)({\n    value,\n    createEmpty,\n    append,\n    getLastChild,\n    getParent,\n    isText,\n    getText,\n    remove,\n    appendText,\n    onStartIndex(body, pointer) {\n      startPath = createPathToNode(pointer, body, [pointer.nodeValue.length]);\n    },\n    onEndIndex(body, pointer) {\n      endPath = createPathToNode(pointer, body, [pointer.nodeValue.length]);\n    },\n    isEditableTree,\n    placeholder\n  });\n  return {\n    body: tree,\n    selection: {\n      startPath,\n      endPath\n    }\n  };\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`.\n *\n * @param {Object}        $1                       Named arguments.\n * @param {RichTextValue} $1.value                 Value to apply.\n * @param {HTMLElement}   $1.current               The live root node to apply the element tree to.\n * @param {Function}      [$1.prepareEditableTree] Function to filter editorable formats.\n * @param {boolean}       [$1.__unstableDomOnly]   Only apply elements, no selection.\n * @param {string}        [$1.placeholder]         Placeholder text.\n */\nfunction apply({\n  value,\n  current,\n  prepareEditableTree,\n  __unstableDomOnly,\n  placeholder\n}) {\n  // Construct a new element tree in memory.\n  const {\n    body,\n    selection\n  } = toDom({\n    value,\n    prepareEditableTree,\n    placeholder,\n    doc: current.ownerDocument\n  });\n  applyValue(body, current);\n  if (value.start !== undefined && !__unstableDomOnly) {\n    applySelection(selection, current);\n  }\n}\nfunction applyValue(future, current) {\n  let i = 0;\n  let futureChild;\n  while (futureChild = future.firstChild) {\n    const currentChild = current.childNodes[i];\n    if (!currentChild) {\n      current.appendChild(futureChild);\n    } else if (!currentChild.isEqualNode(futureChild)) {\n      if (currentChild.nodeName !== futureChild.nodeName || currentChild.nodeType === currentChild.TEXT_NODE && currentChild.data !== futureChild.data) {\n        current.replaceChild(futureChild, currentChild);\n      } else {\n        const currentAttributes = currentChild.attributes;\n        const futureAttributes = futureChild.attributes;\n        if (currentAttributes) {\n          let ii = currentAttributes.length;\n\n          // Reverse loop because `removeAttribute` on `currentChild`\n          // changes `currentAttributes`.\n          while (ii--) {\n            const {\n              name\n            } = currentAttributes[ii];\n            if (!futureChild.getAttribute(name)) {\n              currentChild.removeAttribute(name);\n            }\n          }\n        }\n        if (futureAttributes) {\n          for (let ii = 0; ii < futureAttributes.length; ii++) {\n            const {\n              name,\n              value\n            } = futureAttributes[ii];\n            if (currentChild.getAttribute(name) !== value) {\n              currentChild.setAttribute(name, value);\n            }\n          }\n        }\n        applyValue(futureChild, currentChild);\n        future.removeChild(futureChild);\n      }\n    } else {\n      future.removeChild(futureChild);\n    }\n    i++;\n  }\n  while (current.childNodes[i]) {\n    current.removeChild(current.childNodes[i]);\n  }\n}\nfunction applySelection({\n  startPath,\n  endPath\n}, current) {\n  const {\n    node: startContainer,\n    offset: startOffset\n  } = getNodeByPath(current, startPath);\n  const {\n    node: endContainer,\n    offset: endOffset\n  } = getNodeByPath(current, endPath);\n  const {\n    ownerDocument\n  } = current;\n  const {\n    defaultView\n  } = ownerDocument;\n  const selection = defaultView.getSelection();\n  const range = ownerDocument.createRange();\n  range.setStart(startContainer, startOffset);\n  range.setEnd(endContainer, endOffset);\n  const {\n    activeElement\n  } = ownerDocument;\n  if (selection.rangeCount > 0) {\n    // If the to be added range and the live range are the same, there's no\n    // need to remove the live range and add the equivalent range.\n    if ((0, _isRangeEqual.isRangeEqual)(range, selection.getRangeAt(0))) {\n      return;\n    }\n    selection.removeAllRanges();\n  }\n  selection.addRange(range);\n\n  // This function is not intended to cause a shift in focus. Since the above\n  // selection manipulations may shift focus, ensure that focus is restored to\n  // its previous state.\n  if (activeElement !== ownerDocument.activeElement) {\n    // The `instanceof` checks protect against edge cases where the focused\n    // element is not of the interface HTMLElement (does not have a `focus`\n    // or `blur` property).\n    //\n    // See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n    if (activeElement instanceof defaultView.HTMLElement) {\n      activeElement.focus();\n    }\n  }\n}\n//# sourceMappingURL=to-dom.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toHTMLString = toHTMLString;\nvar _escapeHtml = require(\"@wordpress/escape-html\");\nvar _toTree = require(\"./to-tree\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Create an HTML string from a Rich Text value.\n *\n * @param {Object}        $1                      Named arguments.\n * @param {RichTextValue} $1.value                Rich text value.\n * @param {boolean}       [$1.preserveWhiteSpace] Preserves newlines if true.\n *\n * @return {string} HTML string.\n */\nfunction toHTMLString({\n  value,\n  preserveWhiteSpace\n}) {\n  const tree = (0, _toTree.toTree)({\n    value,\n    preserveWhiteSpace,\n    createEmpty,\n    append,\n    getLastChild,\n    getParent,\n    isText,\n    getText,\n    remove,\n    appendText\n  });\n  return createChildrenHTML(tree.children);\n}\nfunction createEmpty() {\n  return {};\n}\nfunction getLastChild({\n  children\n}) {\n  return children && children[children.length - 1];\n}\nfunction append(parent, object) {\n  if (typeof object === 'string') {\n    object = {\n      text: object\n    };\n  }\n  object.parent = parent;\n  parent.children = parent.children || [];\n  parent.children.push(object);\n  return object;\n}\nfunction appendText(object, text) {\n  object.text += text;\n}\nfunction getParent({\n  parent\n}) {\n  return parent;\n}\nfunction isText({\n  text\n}) {\n  return typeof text === 'string';\n}\nfunction getText({\n  text\n}) {\n  return text;\n}\nfunction remove(object) {\n  const index = object.parent.children.indexOf(object);\n  if (index !== -1) {\n    object.parent.children.splice(index, 1);\n  }\n  return object;\n}\nfunction createElementHTML({\n  type,\n  attributes,\n  object,\n  children\n}) {\n  if (type === '#comment') {\n    // We can't restore the original comment delimiters, because once parsed\n    // into DOM nodes, we don't have the information. But in the future we\n    // could allow comment handlers to specify custom delimiters, for\n    // example `</{comment-content}>` for Bits, where `comment-content`\n    // would be `/{bit-name}` or `__{translatable-string}` (TBD).\n    return `<!--${attributes['data-rich-text-comment']}-->`;\n  }\n  let attributeString = '';\n  for (const key in attributes) {\n    if (!(0, _escapeHtml.isValidAttributeName)(key)) {\n      continue;\n    }\n    attributeString += ` ${key}=\"${(0, _escapeHtml.escapeAttribute)(attributes[key])}\"`;\n  }\n  if (object) {\n    return `<${type}${attributeString}>`;\n  }\n  return `<${type}${attributeString}>${createChildrenHTML(children)}</${type}>`;\n}\nfunction createChildrenHTML(children = []) {\n  return children.map(child => {\n    if (child.html !== undefined) {\n      return child.html;\n    }\n    return child.text === undefined ? createElementHTML(child) : (0, _escapeHtml.escapeEditableHTML)(child.text);\n  }).join('');\n}\n//# sourceMappingURL=to-html-string.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toTree = toTree;\nvar _getActiveFormats = require(\"./get-active-formats\");\nvar _getFormatType = require(\"./get-format-type\");\nvar _specialCharacters = require(\"./special-characters\");\n/**\n * Internal dependencies\n */\n\nfunction restoreOnAttributes(attributes, isEditableTree) {\n  if (isEditableTree) {\n    return attributes;\n  }\n  const newAttributes = {};\n  for (const key in attributes) {\n    let newKey = key;\n    if (key.startsWith('data-disable-rich-text-')) {\n      newKey = key.slice('data-disable-rich-text-'.length);\n    }\n    newAttributes[newKey] = attributes[key];\n  }\n  return newAttributes;\n}\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param {Object}  $1                        Named parameters.\n * @param {string}  $1.type                   The format type.\n * @param {string}  $1.tagName                The tag name.\n * @param {Object}  $1.attributes             The format attributes.\n * @param {Object}  $1.unregisteredAttributes The unregistered format\n *                                            attributes.\n * @param {boolean} $1.object                 Whether or not it is an object\n *                                            format.\n * @param {boolean} $1.boundaryClass          Whether or not to apply a boundary\n *                                            class.\n * @param {boolean} $1.isEditableTree\n *\n * @return {Object} Information to be used for element creation.\n */\nfunction fromFormat({\n  type,\n  tagName,\n  attributes,\n  unregisteredAttributes,\n  object,\n  boundaryClass,\n  isEditableTree\n}) {\n  const formatType = (0, _getFormatType.getFormatType)(type);\n  let elementAttributes = {};\n  if (boundaryClass && isEditableTree) {\n    elementAttributes['data-rich-text-format-boundary'] = 'true';\n  }\n  if (!formatType) {\n    if (attributes) {\n      elementAttributes = {\n        ...attributes,\n        ...elementAttributes\n      };\n    }\n    return {\n      type,\n      attributes: restoreOnAttributes(elementAttributes, isEditableTree),\n      object\n    };\n  }\n  elementAttributes = {\n    ...unregisteredAttributes,\n    ...elementAttributes\n  };\n  for (const name in attributes) {\n    const key = formatType.attributes ? formatType.attributes[name] : false;\n    if (key) {\n      elementAttributes[key] = attributes[name];\n    } else {\n      elementAttributes[name] = attributes[name];\n    }\n  }\n  if (formatType.className) {\n    if (elementAttributes.class) {\n      elementAttributes.class = `${formatType.className} ${elementAttributes.class}`;\n    } else {\n      elementAttributes.class = formatType.className;\n    }\n  }\n\n  // When a format is declared as non editable, make it non editable in the\n  // editor.\n  if (isEditableTree && formatType.contentEditable === false) {\n    elementAttributes.contenteditable = 'false';\n  }\n  return {\n    type: tagName || formatType.tagName,\n    object: formatType.object,\n    attributes: restoreOnAttributes(elementAttributes, isEditableTree)\n  };\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil(a, b, index) {\n  do {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  } while (index--);\n  return true;\n}\nfunction toTree({\n  value,\n  preserveWhiteSpace,\n  createEmpty,\n  append,\n  getLastChild,\n  getParent,\n  isText,\n  getText,\n  remove,\n  appendText,\n  onStartIndex,\n  onEndIndex,\n  isEditableTree,\n  placeholder\n}) {\n  const {\n    formats,\n    replacements,\n    text,\n    start,\n    end\n  } = value;\n  const formatsLength = formats.length + 1;\n  const tree = createEmpty();\n  const activeFormats = (0, _getActiveFormats.getActiveFormats)(value);\n  const deepestActiveFormat = activeFormats[activeFormats.length - 1];\n  let lastCharacterFormats;\n  let lastCharacter;\n  append(tree, '');\n  for (let i = 0; i < formatsLength; i++) {\n    const character = text.charAt(i);\n    const shouldInsertPadding = isEditableTree && (\n    // Pad the line if the line is empty.\n    !lastCharacter ||\n    // Pad the line if the previous character is a line break, otherwise\n    // the line break won't be visible.\n    lastCharacter === '\\n');\n    const characterFormats = formats[i];\n    let pointer = getLastChild(tree);\n    if (characterFormats) {\n      characterFormats.forEach((format, formatIndex) => {\n        if (pointer && lastCharacterFormats &&\n        // Reuse the last element if all formats remain the same.\n        isEqualUntil(characterFormats, lastCharacterFormats, formatIndex)) {\n          pointer = getLastChild(pointer);\n          return;\n        }\n        const {\n          type,\n          tagName,\n          attributes,\n          unregisteredAttributes\n        } = format;\n        const boundaryClass = isEditableTree && format === deepestActiveFormat;\n        const parent = getParent(pointer);\n        const newNode = append(parent, fromFormat({\n          type,\n          tagName,\n          attributes,\n          unregisteredAttributes,\n          boundaryClass,\n          isEditableTree\n        }));\n        if (isText(pointer) && getText(pointer).length === 0) {\n          remove(pointer);\n        }\n        pointer = append(newNode, '');\n      });\n    }\n\n    // If there is selection at 0, handle it before characters are inserted.\n    if (i === 0) {\n      if (onStartIndex && start === 0) {\n        onStartIndex(tree, pointer);\n      }\n      if (onEndIndex && end === 0) {\n        onEndIndex(tree, pointer);\n      }\n    }\n    if (character === _specialCharacters.OBJECT_REPLACEMENT_CHARACTER) {\n      const replacement = replacements[i];\n      if (!replacement) {\n        continue;\n      }\n      const {\n        type,\n        attributes,\n        innerHTML\n      } = replacement;\n      const formatType = (0, _getFormatType.getFormatType)(type);\n      if (isEditableTree && type === '#comment') {\n        pointer = append(getParent(pointer), {\n          type: 'span',\n          attributes: {\n            contenteditable: 'false',\n            'data-rich-text-comment': attributes['data-rich-text-comment']\n          }\n        });\n        append(append(pointer, {\n          type: 'span'\n        }), attributes['data-rich-text-comment'].trim());\n      } else if (!isEditableTree && type === 'script') {\n        pointer = append(getParent(pointer), fromFormat({\n          type: 'script',\n          isEditableTree\n        }));\n        append(pointer, {\n          html: decodeURIComponent(attributes['data-rich-text-script'])\n        });\n      } else if (formatType?.contentEditable === false) {\n        // For non editable formats, render the stored inner HTML.\n        pointer = append(getParent(pointer), fromFormat({\n          ...replacement,\n          isEditableTree,\n          boundaryClass: start === i && end === i + 1\n        }));\n        if (innerHTML) {\n          append(pointer, {\n            html: innerHTML\n          });\n        }\n      } else {\n        pointer = append(getParent(pointer), fromFormat({\n          ...replacement,\n          object: true,\n          isEditableTree\n        }));\n      }\n      // Ensure pointer is text node.\n      pointer = append(getParent(pointer), '');\n    } else if (!preserveWhiteSpace && character === '\\n') {\n      pointer = append(getParent(pointer), {\n        type: 'br',\n        attributes: isEditableTree ? {\n          'data-rich-text-line-break': 'true'\n        } : undefined,\n        object: true\n      });\n      // Ensure pointer is text node.\n      pointer = append(getParent(pointer), '');\n    } else if (!isText(pointer)) {\n      pointer = append(getParent(pointer), character);\n    } else {\n      appendText(pointer, character);\n    }\n    if (onStartIndex && start === i + 1) {\n      onStartIndex(tree, pointer);\n    }\n    if (onEndIndex && end === i + 1) {\n      onEndIndex(tree, pointer);\n    }\n    if (shouldInsertPadding && i === text.length) {\n      append(getParent(pointer), _specialCharacters.ZWNBSP);\n\n      // We CANNOT use CSS to add a placeholder with pseudo elements on\n      // the main block wrappers because that could clash with theme CSS.\n      if (placeholder && text.length === 0) {\n        append(getParent(pointer), {\n          type: 'span',\n          attributes: {\n            'data-rich-text-placeholder': placeholder,\n            // Necessary to prevent the placeholder from catching\n            // selection and being editable.\n            style: 'pointer-events:none;user-select:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;'\n          }\n        });\n      }\n    }\n    lastCharacterFormats = characterFormats;\n    lastCharacter = character;\n  }\n  return tree;\n}\n//# sourceMappingURL=to-tree.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toggleFormat = toggleFormat;\nvar _a11y = require(\"@wordpress/a11y\");\nvar _i18n = require(\"@wordpress/i18n\");\nvar _getActiveFormat = require(\"./get-active-format\");\nvar _removeFormat = require(\"./remove-format\");\nvar _applyFormat = require(\"./apply-format\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n/** @typedef {import('./types').RichTextFormat} RichTextFormat */\n\n/**\n * Toggles a format object to a Rich Text value at the current selection.\n *\n * @param {RichTextValue}  value  Value to modify.\n * @param {RichTextFormat} format Format to apply or remove.\n *\n * @return {RichTextValue} A new value with the format applied or removed.\n */\nfunction toggleFormat(value, format) {\n  if ((0, _getActiveFormat.getActiveFormat)(value, format.type)) {\n    // For screen readers, will announce if formatting control is disabled.\n    if (format.title) {\n      // translators: %s: title of the formatting control\n      (0, _a11y.speak)((0, _i18n.sprintf)((0, _i18n.__)('%s removed.'), format.title), 'assertive');\n    }\n    return (0, _removeFormat.removeFormat)(value, format.type);\n  }\n  // For screen readers, will announce if formatting control is enabled.\n  if (format.title) {\n    // translators: %s: title of the formatting control\n    (0, _a11y.speak)((0, _i18n.sprintf)((0, _i18n.__)('%s applied.'), format.title), 'assertive');\n  }\n  return (0, _applyFormat.applyFormat)(value, format);\n}\n//# sourceMappingURL=toggle-format.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unregisterFormatType = unregisterFormatType;\nvar _data = require(\"@wordpress/data\");\nvar _store = require(\"./store\");\n/**\n * WordPress dependencies\n */\n\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./register-format-type').WPFormat} WPFormat */\n\n/**\n * Unregisters a format.\n *\n * @param {string} name Format name.\n *\n * @return {WPFormat|undefined} The previous format value, if it has\n *                                        been successfully unregistered;\n *                                        otherwise `undefined`.\n */\nfunction unregisterFormatType(name) {\n  const oldFormat = (0, _data.select)(_store.store).getFormatType(name);\n  if (!oldFormat) {\n    window.console.error(`Format ${name} is not registered.`);\n    return;\n  }\n  (0, _data.dispatch)(_store.store).removeFormatTypes(name);\n  return oldFormat;\n}\n//# sourceMappingURL=unregister-format-type.js.map","/* wp:polyfill */\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.updateFormats = updateFormats;\nvar _isFormatEqual = require(\"./is-format-equal\");\n/**\n * Internal dependencies\n */\n\n/** @typedef {import('./types').RichTextValue} RichTextValue */\n\n/**\n * Efficiently updates all the formats from `start` (including) until `end`\n * (excluding) with the active formats. Mutates `value`.\n *\n * @param {Object}        $1         Named paramentes.\n * @param {RichTextValue} $1.value   Value te update.\n * @param {number}        $1.start   Index to update from.\n * @param {number}        $1.end     Index to update until.\n * @param {Array}         $1.formats Replacement formats.\n *\n * @return {RichTextValue} Mutated value.\n */\nfunction updateFormats({\n  value,\n  start,\n  end,\n  formats\n}) {\n  // Start and end may be switched in case of delete.\n  const min = Math.min(start, end);\n  const max = Math.max(start, end);\n  const formatsBefore = value.formats[min - 1] || [];\n  const formatsAfter = value.formats[max] || [];\n\n  // First, fix the references. If any format right before or after are\n  // equal, the replacement format should use the same reference.\n  value.activeFormats = formats.map((format, index) => {\n    if (formatsBefore[index]) {\n      if ((0, _isFormatEqual.isFormatEqual)(format, formatsBefore[index])) {\n        return formatsBefore[index];\n      }\n    } else if (formatsAfter[index]) {\n      if ((0, _isFormatEqual.isFormatEqual)(format, formatsAfter[index])) {\n        return formatsAfter[index];\n      }\n    }\n    return format;\n  });\n  while (--end >= start) {\n    if (value.activeFormats.length > 0) {\n      value.formats[end] = value.activeFormats;\n    } else {\n      delete value.formats[end];\n    }\n  }\n  return value;\n}\n//# sourceMappingURL=update-formats.js.map","module.exports = window[\"wp\"][\"a11y\"];","module.exports = window[\"wp\"][\"compose\"];","module.exports = window[\"wp\"][\"data\"];","module.exports = window[\"wp\"][\"deprecated\"];","module.exports = window[\"wp\"][\"element\"];","module.exports = window[\"wp\"][\"escapeHtml\"];","module.exports = window[\"wp\"][\"i18n\"];","module.exports = window[\"wp\"][\"keycodes\"];","function _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"RichTextData\", {\n  enumerable: true,\n  get: function () {\n    return _create.RichTextData;\n  }\n});\nObject.defineProperty(exports, \"__experimentalRichText\", {\n  enumerable: true,\n  get: function () {\n    return _component.default;\n  }\n});\nObject.defineProperty(exports, \"__unstableCreateElement\", {\n  enumerable: true,\n  get: function () {\n    return _createElement.createElement;\n  }\n});\nObject.defineProperty(exports, \"__unstableToDom\", {\n  enumerable: true,\n  get: function () {\n    return _toDom.toDom;\n  }\n});\nObject.defineProperty(exports, \"__unstableUseRichText\", {\n  enumerable: true,\n  get: function () {\n    return _component.useRichText;\n  }\n});\nObject.defineProperty(exports, \"applyFormat\", {\n  enumerable: true,\n  get: function () {\n    return _applyFormat.applyFormat;\n  }\n});\nObject.defineProperty(exports, \"concat\", {\n  enumerable: true,\n  get: function () {\n    return _concat.concat;\n  }\n});\nObject.defineProperty(exports, \"create\", {\n  enumerable: true,\n  get: function () {\n    return _create.create;\n  }\n});\nObject.defineProperty(exports, \"getActiveFormat\", {\n  enumerable: true,\n  get: function () {\n    return _getActiveFormat.getActiveFormat;\n  }\n});\nObject.defineProperty(exports, \"getActiveFormats\", {\n  enumerable: true,\n  get: function () {\n    return _getActiveFormats.getActiveFormats;\n  }\n});\nObject.defineProperty(exports, \"getActiveObject\", {\n  enumerable: true,\n  get: function () {\n    return _getActiveObject.getActiveObject;\n  }\n});\nObject.defineProperty(exports, \"getTextContent\", {\n  enumerable: true,\n  get: function () {\n    return _getTextContent.getTextContent;\n  }\n});\nObject.defineProperty(exports, \"insert\", {\n  enumerable: true,\n  get: function () {\n    return _insert.insert;\n  }\n});\nObject.defineProperty(exports, \"insertObject\", {\n  enumerable: true,\n  get: function () {\n    return _insertObject.insertObject;\n  }\n});\nObject.defineProperty(exports, \"isCollapsed\", {\n  enumerable: true,\n  get: function () {\n    return _isCollapsed.isCollapsed;\n  }\n});\nObject.defineProperty(exports, \"isEmpty\", {\n  enumerable: true,\n  get: function () {\n    return _isEmpty.isEmpty;\n  }\n});\nObject.defineProperty(exports, \"join\", {\n  enumerable: true,\n  get: function () {\n    return _join.join;\n  }\n});\nObject.defineProperty(exports, \"registerFormatType\", {\n  enumerable: true,\n  get: function () {\n    return _registerFormatType.registerFormatType;\n  }\n});\nObject.defineProperty(exports, \"remove\", {\n  enumerable: true,\n  get: function () {\n    return _remove.remove;\n  }\n});\nObject.defineProperty(exports, \"removeFormat\", {\n  enumerable: true,\n  get: function () {\n    return _removeFormat.removeFormat;\n  }\n});\nObject.defineProperty(exports, \"replace\", {\n  enumerable: true,\n  get: function () {\n    return _replace.replace;\n  }\n});\nObject.defineProperty(exports, \"slice\", {\n  enumerable: true,\n  get: function () {\n    return _slice.slice;\n  }\n});\nObject.defineProperty(exports, \"split\", {\n  enumerable: true,\n  get: function () {\n    return _split.split;\n  }\n});\nObject.defineProperty(exports, \"store\", {\n  enumerable: true,\n  get: function () {\n    return _store.store;\n  }\n});\nObject.defineProperty(exports, \"toHTMLString\", {\n  enumerable: true,\n  get: function () {\n    return _toHtmlString.toHTMLString;\n  }\n});\nObject.defineProperty(exports, \"toggleFormat\", {\n  enumerable: true,\n  get: function () {\n    return _toggleFormat.toggleFormat;\n  }\n});\nObject.defineProperty(exports, \"unregisterFormatType\", {\n  enumerable: true,\n  get: function () {\n    return _unregisterFormatType.unregisterFormatType;\n  }\n});\nObject.defineProperty(exports, \"useAnchor\", {\n  enumerable: true,\n  get: function () {\n    return _useAnchor.useAnchor;\n  }\n});\nObject.defineProperty(exports, \"useAnchorRef\", {\n  enumerable: true,\n  get: function () {\n    return _useAnchorRef.useAnchorRef;\n  }\n});\nvar _store = require(\"./store\");\nvar _applyFormat = require(\"./apply-format\");\nvar _concat = require(\"./concat\");\nvar _create = require(\"./create\");\nvar _getActiveFormat = require(\"./get-active-format\");\nvar _getActiveFormats = require(\"./get-active-formats\");\nvar _getActiveObject = require(\"./get-active-object\");\nvar _getTextContent = require(\"./get-text-content\");\nvar _isCollapsed = require(\"./is-collapsed\");\nvar _isEmpty = require(\"./is-empty\");\nvar _join = require(\"./join\");\nvar _registerFormatType = require(\"./register-format-type\");\nvar _removeFormat = require(\"./remove-format\");\nvar _remove = require(\"./remove\");\nvar _replace = require(\"./replace\");\nvar _insert = require(\"./insert\");\nvar _insertObject = require(\"./insert-object\");\nvar _slice = require(\"./slice\");\nvar _split = require(\"./split\");\nvar _toDom = require(\"./to-dom\");\nvar _toHtmlString = require(\"./to-html-string\");\nvar _toggleFormat = require(\"./toggle-format\");\nvar _unregisterFormatType = require(\"./unregister-format-type\");\nvar _createElement = require(\"./create-element\");\nvar _useAnchorRef = require(\"./component/use-anchor-ref\");\nvar _useAnchor = require(\"./component/use-anchor\");\nvar _component = _interopRequireWildcard(require(\"./component\"));\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n//# sourceMappingURL=index.js.map"],"names":[],"sourceRoot":""}